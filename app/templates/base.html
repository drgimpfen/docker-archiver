<!doctype html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="csrf-token" content="{{ csrf_token() }}">
    <title>Docker Archiver</title>
    <link rel="icon" href="{{ url_for('static', filename='icons/Icon.png') }}" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
    /* Log terminal styles */
    .log {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
        font-size: 0.9rem;
        line-height: 1.4rem;
        color: #e6e6e6;
    }
    .log-line { display: flex; gap: 8px; padding: 2px 4px; }
    .log-line .ln { color: #777; width: 40px; flex: 0 0 40px; text-align: right; user-select: none; }
    .log-line .text { white-space: pre-wrap; word-break: break-word; flex: 1 1 auto; }
    .level-ERROR { color: #ff6b6b; font-weight: 700; }
    .level-WARNING { color: #ffc542; font-weight: 600; }
    .level-INFO { color: #6bc8ff; }
    .level-DEBUG { color: #9aa4b2; }
    .log-line.muted { opacity: 0.8; }
    .log-highlight { background: rgba(255,255,0,0.12); }
    .paused-indicator { display:inline-block; background:#ff6b6b; color:white; padding:2px 6px; border-radius:4px; font-weight:600; margin-left:8px; }
    /* Sidebar chevron rotation for settings submenu */
    .nav-link .bi-chevron-down { transition: transform .18s ease; }
    .nav-link.open .bi-chevron-down { transform: rotate(180deg); }

    /* Card header / title consistency */
    .card-header h5.mb-0, .card-header .card-title { display:flex; align-items:center; gap:.625rem; font-size:1rem; margin:0; }
    .card-header .bi { font-size:1.15rem; }
    /* Section headings inside card bodies */
    .card-body h6 { margin-top:0; margin-bottom:.75rem; font-size:0.95rem; font-weight:600; }

    /* Consistent action bar spacing (left-aligned) */
    .form-actions { margin-top:1rem; display:flex; gap:0.5rem; justify-content:flex-start; }
    </style>
</head>
<body>
    <script>
        // Global error hooks for debugging (early registration)
        window.addEventListener('error', function(e){
            try { console.error('Global error', e.message, e.filename, e.lineno, e.colno, e.error); } catch(_){}
        });
        window.addEventListener('unhandledrejection', function(e){
            try { console.error('Unhandled rejection', e.reason); } catch(_){}
        });
    </script>
    {% if session.user_id %}
    <aside class="app-sidebar" id="app-sidebar">
        <!-- Logo -->
        <div class="sidebar-header">
            <a href="{{ url_for('dashboard.index') }}" class="d-flex align-items-center text-decoration-none">
                <img src="{{ url_for('static', filename='images/Logo.png') }}" alt="Docker Archiver" style="max-width: 200px; height: auto;">
            </a>
        </div>

        <!-- Navigation -->
        {% set _endpoint = request.endpoint or '' %}
        <ul class="nav flex-column">
            <li class="nav-item"><a class="nav-link{% if _endpoint == 'dashboard.index' %} active{% endif %}" href="{{ url_for('dashboard.index') }}"><i class="bi bi-house-door me-2"></i>Dashboard</a></li>
            <li class="nav-item"><a class="nav-link{% if _endpoint.startswith('history.') %} active{% endif %}" href="{{ url_for('history.list_history') }}"><i class="bi bi-clock-history me-2"></i>History</a></li>
            <li class="nav-item"><a class="nav-link{% if _endpoint.startswith('downloads.') %} active{% endif %}" href="{{ url_for('downloads.manage_downloads') }}"><i class="bi bi-download me-2"></i>Downloads</a></li>
            {% set _current_path = request.path %}
            {% set _settings_open = _endpoint.startswith('settings.') %}
            <li class="nav-item">
                <a class="nav-link d-flex justify-content-between align-items-center {% if _settings_open %}open{% endif %}" data-bs-toggle="collapse" href="#sidebarSettings" role="button" aria-expanded="{{ 'true' if _settings_open else 'false' }}" aria-controls="sidebarSettings">
                    <span><i class="bi bi-gear me-2"></i>Settings</span>
                    <i class="bi bi-chevron-down small"></i>
                </a>
                <div class="collapse {% if _settings_open %}show{% endif %}" id="sidebarSettings">
                    <ul class="nav flex-column ms-3">
                        <li class="nav-item"><a class="nav-link{% if _endpoint == 'settings.manage_settings' %} active{% endif %}" href="{{ url_for('settings.manage_settings') }}">General</a></li>
                        <li class="nav-item"><a class="nav-link{% if _endpoint == 'settings.manage_profile' %} active{% endif %}" href="{{ url_for('settings.manage_profile') }}">Profile</a></li>
                        <li class="nav-item"><a class="nav-link{% if _endpoint == 'settings.manage_notifications' %} active{% endif %}" href="{{ url_for('settings.manage_notifications') }}">Notifications</a></li>
                        <li class="nav-item"><a class="nav-link{% if _endpoint == 'settings.manage_security' %} active{% endif %}" href="{{ url_for('settings.manage_security') }}">Security</a></li>
                        <li class="nav-item"><a class="nav-link{% if _endpoint == 'settings.manage_cleanup' %} active{% endif %}" href="{{ url_for('settings.manage_cleanup') }}">Cleanup</a></li>
                    </ul>
                </div>
            </li> 
        </ul>

        <!-- Sidebar Bottom -->
        <div class="sidebar-bottom">
            <div class="d-flex justify-content-center gap-3 mb-3">
                <a href="https://github.com/drgimpfen/Docker-Archiver/" target="_blank" rel="noopener" title="GitHub">
                    <img src="{{ url_for('static', filename='icons/github-mark-white.png') }}" alt="GitHub" class="theme-icon-dark" style="height:20px;" />
                    <img src="{{ url_for('static', filename='icons/github-mark.png') }}" alt="GitHub" class="theme-icon-light" style="height:20px;display:none;" />
                </a>
                <a href="https://discord.gg/Tq84tczrR2" target="_blank" rel="noopener" title="Discord">
                    <img src="{{ url_for('static', filename='icons/Discord-Symbol-White.png') }}" alt="Discord" class="theme-icon-dark" style="height:20px;" />
                    <img src="{{ url_for('static', filename='icons/Discord-Symbol-Black.png') }}" alt="Discord" class="theme-icon-light" style="height:20px;display:none;" />
                </a>
                <a id="theme-toggle" href="#" title="Toggle theme" style="font-size: 20px; text-decoration: none;">üåô</a>
            </div>
            <a href="{{ url_for('logout') }}" class="btn btn-outline-danger btn-sm w-100 mb-2">
                <i class="bi bi-box-arrow-right me-1"></i>Logout
            </a>
            <div class="text-center">
                <small class="text-muted">v{{ app_version }}</small>
            </div>
        </div>
    </aside>

    <!-- Mobile Toggle Button -->
    <button id="sidebar-toggle" class="btn btn-outline-secondary d-lg-none" style="position: fixed; top: 10px; left: 10px; z-index: 1040;" aria-label="Toggle menu">‚ò∞</button>
    {% endif %}

    <main class="app-main mt-4">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% set _seen = [] %}
                {% for category, message in messages %}
                    {% set key = category ~ '::' ~ message %}
                    {% if key not in _seen %}
                        <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                            {{ message }}
                            <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                        </div>
                        {% set _seen = _seen + [key] %}
                    {% endif %}
                {% endfor %}
            {% endif %}
        {% endwith %}


        {% block content %}{% endblock %}
    </main>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // CSRF Token setup for AJAX requests
        (function(){
            const csrfToken = document.querySelector('meta[name="csrf-token"]');
            if (csrfToken) {
                // Setup default headers for fetch
                const originalFetch = window.fetch;
                window.fetch = function(...args) {
                    if (args[1] && (args[1].method === 'POST' || args[1].method === 'PUT' || args[1].method === 'DELETE')) {
                        args[1].headers = args[1].headers || {};
                        args[1].headers['X-CSRFToken'] = csrfToken.content;
                    }
                    return originalFetch.apply(this, args);
                };
            }
        })();

        // Persisted Line Number setting
        function getShowLineNumbers() {
            try { return localStorage.getItem('showLineNumbers') === 'true'; } catch (e) { return false; }
        }
        function setShowLineNumbers(v) {
            try { localStorage.setItem('showLineNumbers', v ? 'true' : 'false'); } catch (e) {}
        }


        
        // Bootstrap 5 native theme toggle
        (function(){
            const toggle = document.getElementById('theme-toggle');
            const htmlElement = document.documentElement;
            
            // Get stored theme or default to dark
            const storedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const currentTheme = storedTheme || (prefersDark ? 'dark' : 'light');
            
            // Set initial theme
            htmlElement.setAttribute('data-bs-theme', currentTheme);
            updateThemeIcon(currentTheme);
            
            // Toggle handler
            if (toggle) {
                toggle.addEventListener('click', function(e) {
                    e.preventDefault();
                    const theme = htmlElement.getAttribute('data-bs-theme');
                    const newTheme = theme === 'dark' ? 'light' : 'dark';
                    htmlElement.setAttribute('data-bs-theme', newTheme);
                    localStorage.setItem('theme', newTheme);
                    updateThemeIcon(newTheme);
                });
            }
            
            function updateThemeIcon(theme) {
                if (toggle) {
                    toggle.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                    toggle.title = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
                }
            }
        })();
    </script>
    <script>
        // Add class when sidebar exists so we only shift main content when sidebar is present
        (function(){
            if (document.getElementById('app-sidebar')) {
                document.body.classList.add('has-sidebar');
            }
        })();

        // Update theme icons visibility
        function updateThemeIcons() {
            const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';
            document.querySelectorAll('.theme-icon-dark').forEach(el => el.style.display = isDark ? '' : 'none');
            document.querySelectorAll('.theme-icon-light').forEach(el => el.style.display = isDark ? 'none' : '');
        }
        updateThemeIcons();
        
        // Observe theme changes
        const observer = new MutationObserver(updateThemeIcons);
        observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-bs-theme'] });
    </script>
    <script>
        // Sidebar toggle for small screens
        (function(){
            const btn = document.getElementById('sidebar-toggle');
            const body = document.body;
            btn && btn.addEventListener('click', function(e){
                e.preventDefault();
                body.classList.toggle('sidebar-open');
            });
        })();

        // Toggle chevron rotation when settings collapse opens/closes
        (function(){
            const collapseEl = document.getElementById('sidebarSettings');
            const anchor = document.querySelector('[href="#sidebarSettings"]');
            if (collapseEl && anchor) {
                collapseEl.addEventListener('show.bs.collapse', () => anchor.classList.add('open'));
                collapseEl.addEventListener('hide.bs.collapse', () => anchor.classList.remove('open'));
            }
        })();
    </script>
    
    <!-- Job Details Modal (shared across pages) -->
    <div class="modal fade" id="jobDetailsModal" tabindex="-1">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="bi bi-info-circle"></i> Job Details
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body" id="jobDetailsContent">
                    <div class="text-center">
                        <div class="spinner-border" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Download Preparation Modal (used when a requested archive is being prepared) -->
    <div class="modal fade" id="downloadPrepModal" tabindex="-1">
        <div class="modal-dialog modal-sm">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Download preparation</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p id="downloadPrepMessage">The archive is being prepared; you will receive a notification when it's ready.</p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Send Download Link Modal (used to enter recipient email) -->
    <div class="modal fade" id="sendDownloadModal" tabindex="-1">
      <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">Send Download Link</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
          </div>
          <div class="modal-body">
            <div class="mb-3">
              <label for="sendDownloadEmail" class="form-label">Recipient Email</label>
              <input type="email" id="sendDownloadEmail" class="form-control" placeholder="recipient@example.com">
              <input type="hidden" id="sendDownloadToken">
              <input type="hidden" id="sendDownloadArchivePath">
              <input type="hidden" id="sendDownloadStackName">
            </div>
            <div id="sendDownloadFeedback" class="text-muted small"></div>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
            <button type="button" class="btn btn-primary" id="sendDownloadConfirm">Send</button>
          </div>
        </div>
      </div>
    </div>
    
    <script>
    // Global Jobs SSE disabled ‚Äî dashboard relies on polling now.

    // Format ISO 8601 / Z timestamps into a user-friendly local datetime string (YYYY-MM-DD HH:MM:SS)
    function formatDateTime(isoStr){
        if(!isoStr) return 'N/A';
        try{
            const d = new Date(isoStr);
            if (isNaN(d.getTime())) return isoStr;
            return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
        } catch (e){
            return isoStr;
        }
    }

    // Shared job details modal function
    async function showJobDetails(jobId) {
        try {
        } catch (e) {}
        // Track currently-open modal job id for dashboard polling
        window._currentJobId = jobId;
        const modalEl = document.getElementById('jobDetailsModal');
        if (!modalEl) {
            console.error('Job details modal element not found');
            alert('Could not open job details: modal element missing');
            return;
        }

        let modal;
        try {
            modal = new bootstrap.Modal(modalEl);
        } catch (e) {
            console.error('Bootstrap Modal constructor failed', e);
            alert('Could not open job details: modal library not available');
            return;
        }

        const content = document.getElementById('jobDetailsContent');
        try {
            modal.show();
        } catch (e) {
            console.error('Failed to show modal', e);
            alert('Could not open job details: ' + (e && e.message ? e.message : e));
            return;
        }

        // Clear current job id when modal is hidden
        modalEl.addEventListener('hide.bs.modal', () => {
            window._currentJobId = null;
            if (window._jobLogPoller) {
                clearTimeout(window._jobLogPoller);
                window._jobLogPoller = null;
            }
            if (window._jobRefreshTimer) {
                clearTimeout(window._jobRefreshTimer);
                window._jobRefreshTimer = null;
            }
            // Stop any SSE connection
            if (window._jobEventSource) {
                try { window._jobEventSource.close(); } catch(e) {}
                window._jobEventSource = null;
            }
        }, { once: true });
        
        try {
            const response = await fetch(`/api/jobs/${jobId}`, { credentials: 'same-origin' });
            if (!response.ok) {
                content.innerHTML = `<div class="alert alert-danger">Failed to load job details (status ${response.status})</div>`;
                return;
            }
            // Ensure we only parse JSON responses
            const contentType = response.headers.get('content-type') || '';
            if (!contentType.includes('application/json')) {
                content.innerHTML = `<div class="alert alert-danger">Invalid response for job details (expected JSON)</div>`;
                return;
            }
            const data = await response.json();
            
            if (data.error) {
                content.innerHTML = `<div class="alert alert-danger">${data.error}</div>`;
                return;
            }
            
            let job = data.job;
            const metrics = data.metrics;
            
            // Determine compact type/format display (short labels with title tooltips)
            let typeHtml = '';
            if (job.job_type === 'archive') {
                const fmt = job.archive_output_format || 'tar';
                if (fmt === 'folder') {
                    typeHtml = '<i class="bi bi-folder me-1 text-primary"></i> <span title="folder (for borg backup)">folder</span>';
                } else if (fmt === 'tar') {
                    typeHtml = '<i class="bi bi-archive me-1 text-secondary"></i> <span title="tar (no compression)">tar</span>';
                } else if (fmt === 'tar.gz') {
                    typeHtml = '<i class="bi bi-archive me-1 text-info"></i> <span title="tar.gz (gzip)">tgz</span>';
                } else if (fmt === 'tar.zst') {
                    typeHtml = '<i class="bi bi-archive me-1 text-success"></i> <span title="tar.zst (zstd)">zst</span>';
                } else {
                    const short = (fmt.length <= 8) ? fmt : fmt.substring(0,8) + '‚Ä¶';
                    typeHtml = '<i class="bi bi-file-earmark me-1 text-muted"></i> <span title="' + fmt + '">' + short + '</span>';
                }
                if (job.is_dry_run) typeHtml += ' <span class="badge bg-secondary">DRY</span>';
            } else {
                let label = job.job_type.replace('_',' ');
                if (label.length > 6) label = label.substring(0,6) + '‚Ä¶';
                typeHtml = '<span title="' + job.job_type + '">' + label + '</span>' + (job.is_dry_run ? ' <span class="badge bg-secondary">DRY</span>' : '');
            }
            
            let html = `
                <div class="row mb-4">
                    <div class="col-md-6">
                        <h6>Job Information</h6>
                        <table class="table table-sm">
                            <tr><th width="150">Job ID:</th><td>#${job.id}</td></tr>
                            <tr><th>Archive:</th><td id="job-archive-name">${job.archive_name || 'N/A'}</td></tr>
                            <tr><th>Type:</th><td id="job-type">${typeHtml}</td></tr>
                            <tr><th>Status:</th><td><span id="job-status-badge" class="badge bg-${job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger')}">${job.status}</span></td></tr>
                            <tr><th>Triggered By:</th><td id="job-triggered-by">${job.triggered_by}</td></tr>
                        </table>
                    </div>
                    <div class="col-md-6">
                        <h6>Timing & Size</h6>
                        <table class="table table-sm">
                            <tr><th width="150">Start Time:</th><td id="job-start-time" data-start="${job.start_time || ''}">${job.start_time ? formatDateTime(job.start_time) : 'N/A'}</td></tr>
                            <tr><th>End Time:</th><td id="job-end-time" data-end="${job.end_time || ''}">${job.end_time ? formatDateTime(job.end_time) : 'N/A'}</td></tr>
                            <tr><th>Duration:</th><td id="job-duration">${job.duration_seconds !== null && job.duration_seconds !== undefined ? job.duration_seconds + 's' : 'N/A'}</td></tr>
                            <tr><th>Total Size:</th><td id="job-total-size">${job.total_size_bytes ? formatBytes(job.total_size_bytes) : 'N/A'}</td></tr>
                            <tr><th>Reclaimed:</th><td id="job-reclaimed">${job.reclaimed_bytes ? formatBytes(job.reclaimed_bytes) : 'N/A'}</td></tr>
                        </table>
                    </div>
                </div>
            `;
            
            if (job.error_message) {
                html += `
                    <div class="alert alert-danger">
                        <h6>Error</h6>
                        <pre>${job.error_message}</pre>
                    </div>
                `;
            }
            
            if (metrics && metrics.length > 0) {
                html += `
                    <h6 class="mt-4">Stack Metrics</h6>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Stack</th>
                                <th>Status</th>
                                <th>Was Running</th>
                                <th>Duration</th>
                                <th>Archive Size</th>
                                <th>Archive Path</th>
                                <th style="width: 80px;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="job-metrics-body">
                `;
                
                metrics.forEach(m => {
                    const hasArchive = m.archive_path && !m.archive_path.includes('_download_');
                    html += `
                        <tr>
                            <td>${m.stack_name}</td>
                            <td><span class="badge bg-${m.status === 'success' ? 'success' : 'danger'}">${m.status}</span></td>
                            <td>${m.was_running ? '<i class="bi bi-check-circle text-success"></i>' : '<i class="bi bi-x-circle text-muted"></i>'}</td>
                            <td>${m.duration_seconds !== null && m.duration_seconds !== undefined ? m.duration_seconds + 's' : 'N/A'}</td>
                            <td>${m.archive_size_bytes ? formatBytes(m.archive_size_bytes) : 'N/A'}</td>
                            <td><small>${m.archive_path || 'N/A'}</small></td>
                            <td class="text-nowrap">
                                ${hasArchive ? `<button class="btn btn-sm btn-outline-primary me-1" onclick="requestDownload(${job.id}, '${m.stack_name}', '${m.archive_path}')" title="Download Archive"><i class="bi bi-download"></i></button>` : ''}
                                ${hasArchive ? `<button class="btn btn-sm btn-outline-secondary me-1" onclick="showSendDownloadModal('${m.stack_name}', '${m.archive_path}', null)" title="Send Download Link"><i class="bi bi-envelope"></i></button>` : ''}
                                <button class="btn btn-sm btn-outline-secondary" onclick="downloadStackLog(${job.id}, '${m.stack_name}')" title="Download Stack Log"><i class="bi bi-file-text"></i></button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                        </tbody>
                    </table>
                `;
            }
            
            html += `
                <h6 class="mt-4">Log Output
                    <small class="text-muted ms-2">(terminal)</small>
                </h6>
                <div class="d-flex gap-2 align-items-center mb-2">
                    <input id="job-log-search-${job.id}" class="form-control form-control-sm" placeholder="Search log..." style="max-width: 300px;" oninput="(function(){ const v=this.value.toLowerCase(); document.querySelectorAll('#job-log .log-line').forEach(el=>el.classList.toggle('log-highlight', v && el.textContent.toLowerCase().includes(v))); }).call(this)">
                    <button id="job-log-copy-${job.id}" class="btn btn-sm btn-outline-secondary">Copy</button>
                    <button id="job-log-download-${job.id}" class="btn btn-sm btn-outline-secondary">Download</button>
                    <button id="job-log-toggle-autoscroll-${job.id}" class="btn btn-sm btn-outline-primary">Pause</button>
                    <button id="job-log-clear-${job.id}" class="btn btn-sm btn-outline-danger">Clear</button>
                    <button id="job-log-toggle-linenos-${job.id}" class="btn btn-sm btn-outline-secondary">Line #</button>

                    <span id="job-sse-status-${job.id}" class="badge bg-secondary ms-2">Polling</span>
                    <span id="job-paused-indicator-${job.id}" class="paused-indicator" style="display:none;">PAUSED</span>
                </div>
                <div id="job-log" class="bg-dark text-light p-0 mb-2 log console" style="max-height: 400px; overflow-y: auto; border-radius:6px; box-shadow: 0 6px 18px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.04); background: linear-gradient(180deg, #0b0f12 0%, #0f1417 100%);">
                    <div class="console-header">
                        <div class="console-controls" aria-hidden="true">
                            <span class="dot dot-red"></span>
                            <span class="dot dot-yellow"></span>
                            <span class="dot dot-green"></span>
                        </div>
                        <div class="console-title">Terminal</div>
                    </div>
            `;

            content.innerHTML = html;

            // --- Live log polling & job refresh ---
            // Clear existing poller if present
            if (window._jobLogPoller) {
                clearTimeout(window._jobLogPoller);
                window._jobLogPoller = null;
            }

            const logPre = document.getElementById('job-log');
            let lastLine = 0;
            let refreshInterval = 0; // counter to reduce metadata fetch frequency

            // Auto-scroll toggle (default: on)
            window._jobLogAutoScroll = true;
            // Line numbers persisted setting
            window._jobLogShowLineNumbers = getShowLineNumbers();

            function toggleAutoScroll() {
                window._jobLogAutoScroll = !window._jobLogAutoScroll;
                const btn = document.getElementById(`job-log-toggle-autoscroll-${job.id}`);
                const badge = document.getElementById(`job-paused-indicator-${job.id}`);
                if (btn) btn.textContent = window._jobLogAutoScroll ? 'Pause' : 'Resume';
                if (badge) badge.style.display = window._jobLogAutoScroll ? 'none' : '';
            }

            function toggleLineNumbers() {
                window._jobLogShowLineNumbers = !window._jobLogShowLineNumbers;
                // Persist
                setShowLineNumbers(window._jobLogShowLineNumbers);
                // Toggle display for existing lines
                document.querySelectorAll('#job-log .ln').forEach(el => el.style.display = window._jobLogShowLineNumbers ? '' : 'none');
                // Update button UI
                const btn = document.getElementById(`job-log-toggle-linenos-${job.id}`);
                if (btn) {
                    btn.textContent = window._jobLogShowLineNumbers ? 'Hide #' : 'Line #';
                    btn.classList.toggle('btn-success', window._jobLogShowLineNumbers);
                }
            }

            function ensureConsoleHeader(container) {
                if (!container) return;
                if (!container.querySelector('.console-header')) {
                    const header = document.createElement('div');
                    header.className = 'console-header';
                    header.innerHTML = `
                        <div class="console-controls" aria-hidden="true">
                            <span class="dot dot-red"></span>
                            <span class="dot dot-yellow"></span>
                            <span class="dot dot-green"></span>
                        </div>
                        <div class="console-title">Terminal</div>
                    `;
                    container.insertBefore(header, container.firstChild);
                }
            }

            function clearLog() {
                const container = document.getElementById('job-log');
                if (container) {
                    // Remove only log-line children so header remains
                    container.querySelectorAll('.log-line').forEach(el => el.remove());
                }
                lastLine = 0;
                window._jobLogLineCount = 0;
            }

            function toggleLineNumbers() {
                window._jobLogShowLineNumbers = !window._jobLogShowLineNumbers;
                document.querySelectorAll('#job-log .ln').forEach(el => el.style.display = window._jobLogShowLineNumbers ? '' : 'none');
            }

            function appendLogLine(line) {
                // Normalize and split if the incoming line contains multiple timestamped entries
                if (!line) return;
                const tsGlobal = /\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\]/g;
                const matches = Array.from(line.matchAll(tsGlobal));
                if (matches.length > 1) {
                    // Split into chunks that each start with a timestamp
                    const parts = [];
                    for (let i = 0; i < matches.length; i++) {
                        const start = matches[i].index;
                        const end = (i + 1 < matches.length) ? matches[i + 1].index : line.length;
                        parts.push(line.slice(start, end).trim());
                    }
                    parts.forEach(p => appendLogLine(p));
                    return;
                }

                // Ensure container
                const container = document.getElementById('job-log');
                if (!container) return;
                // Ensure header exists (so modal opened later still shows it)
                ensureConsoleHeader(container);
                window._jobLogLineCount = (window._jobLogLineCount || 0) + 1;
                const div = document.createElement('div');
                div.className = 'log-line';
                const ln = document.createElement('div');
                ln.className = 'ln';
                ln.textContent = window._jobLogLineCount;
                ln.style.display = window._jobLogShowLineNumbers ? '' : 'none';
                const text = document.createElement('div');
                text.className = 'text';

                // Try to extract a leading timestamp
                let tsMatch = line.match(/^\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\]\s*/);
                if (!tsMatch) {
                    // If no leading timestamp, try to find one anywhere and trim preceding garbage
                    const anyTs = line.match(/\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\]/);
                    if (anyTs && anyTs.index !== undefined) {
                        line = line.slice(anyTs.index);
                        tsMatch = line.match(/^\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\]\s*/);
                    }
                }

                if (tsMatch) {
                    const ts = tsMatch[0];
                    const tsSpan = document.createElement('span');
                    tsSpan.className = 'ts me-2 text-muted';
                    tsSpan.textContent = ts;
                    text.appendChild(tsSpan);
                    line = line.slice(tsMatch[0].length);
                }

                // Parse level prefix like [ERROR], [WARNING], [INFO], [DEBUG]
                const m = line.match(/^(\[(ERROR|WARNING|INFO|DEBUG)\])\s*/);
                if (m) {
                    const lvlToken = m[1];
                    const lvl = m[2];
                    const levelSpan = document.createElement('span');
                    levelSpan.className = `level-${lvl}`;
                    levelSpan.textContent = lvlToken + ' ';
                    text.appendChild(levelSpan);
                    // Append rest
                    const rest = document.createTextNode(line.slice(m[0].length));
                    text.appendChild(rest);
                } else {
                    // No explicit level at start - append the full line
                    text.appendChild(document.createTextNode(line));
                }

                div.appendChild(ln);
                div.appendChild(text);
                container.appendChild(div);

                // Auto scroll if enabled
                if (window._jobLogAutoScroll !== false) {
                    container.scrollTop = container.scrollHeight;
                }
            }

            // SSE event source for live log + metadata (preferred over polling when supported)
            function startJobEventSource() {
                if (typeof(EventSource) === 'undefined') return;
                if (window._jobEventSource) return;
                try {
                    window._jobEventSource = new EventSource(`/api/jobs/${job.id}/events`);

                    window._jobEventSource.onopen = function() {
                        try { updateSseStatus('live'); } catch (e) {}
                        // Start a short watchdog: if no messages arrive shortly, fall back to polling
                        try {
                            if (window._jobSseIdleTimer) clearTimeout(window._jobSseIdleTimer);
                            window._jobSseIdleTimer = setTimeout(function(){
                                console.warn('No per-job SSE messages received; falling back to polling');
                                try { window._jobEventSource.close(); } catch (e) {}
                                window._jobEventSource = null;
                                try { updateSseStatus('polling'); } catch (e) {}
                                // start polling fallback
                                fetchTail();
                            }, 2000);
                        } catch (e) {}
                    };

                    window._jobEventSource.onmessage = function(e) {
                        try {
                            if (window._jobSseIdleTimer) { clearTimeout(window._jobSseIdleTimer); window._jobSseIdleTimer = null; }
                            const payload = JSON.parse(e.data);
                            handleSseEvent(payload);
                        } catch (err) {
                            // ignore parse errors
                        }
                    };

                    window._jobEventSource.onerror = function(err) {
                        // On error try to close and fall back to polling
                        console.error('SSE error for job', job.id, err);
                        try { window._jobEventSource.close(); } catch (e) {}
                        window._jobEventSource = null;
                        try { updateSseStatus('polling'); } catch (e) {}
                        // Start polling immediately
                        fetchTail();
                    };
                } catch (err) {
                    console.error('Failed to start SSE:', err);
                    try { updateSseStatus('polling'); } catch (e) {}
                }
            }

            // Global SSE events (permissions fixes, job-level broadcasts, etc.)
            // Only open global EventSource if the server supports global SSE (debug endpoint check)
            function startGlobalEventSource(){
                if (typeof(EventSource) === 'undefined') return;
                if (window._globalEventSource) return;

                // Probe server debug endpoint to determine whether global SSE is available
                fetch('/api/_debug/sse', { credentials: 'same-origin' }).then(function(resp){
                    if (!resp.ok) {
                        console.debug('Global SSE not available: debug endpoint returned ' + resp.status);
                        return null;
                    }
                    // Ensure JSON response (not a login redirect HTML)
                    const ct = resp.headers.get('content-type') || '';
                    if (!ct.includes('application/json')) {
                        console.debug('Global SSE debug endpoint returned non-JSON content');
                        return null;
                    }
                    return resp.json();
                }).then(function(data){
                    if (!data || !data.sse) {
                        console.debug('Global SSE not enabled (no debug info)');
                        return;
                    }
                    const s = data.sse || {};
                    // Only attempt to open global SSE if Redis is configured/connected (server-side requirement)
                    if (!s.redis_url_set && !s.use_redis) {
                        console.debug('Global SSE not enabled on server (no Redis)');
                        return;
                    }

                    try {
                        window._globalEventSource = new EventSource('/api/events');
                        window._globalEventSource.onmessage = function(e){
                            try{
                                const payload = JSON.parse(e.data);
                                if(!payload || !payload.type) return;
                                // Handle permissions fix completion
                                if(payload.type === 'permissions_fix_completed'){
                                    const d = payload.data || {};
                                    const files = d.files_changed || 0;
                                    const dirs = d.dirs_changed || 0;
                                    const msg = `Permissions fix completed: ${files} files, ${dirs} dirs fixed`;
                                    if(typeof showAlert === 'function'){
                                        // If there are sample fixes, include a small 'View fixes' link
                                        showAlert(msg, 'success');
                                    }
                                    // If permissions modal is open, refresh its contents
                                    const permModalEl = document.getElementById('permissionsModal');
                                    const isOpen = permModalEl && permModalEl.classList && permModalEl.classList.contains('show');
                                    if(isOpen && typeof checkPermissions === 'function'){
                                        // Refresh the modal contents to reflect current state
                                        checkPermissions();
                                    }
                                }
                            }catch(err){ console.error('Global SSE parse error', err); }
                        };
                        window._globalEventSource.onerror = function(err){
                            try { window._globalEventSource.close(); } catch(e){}
                            window._globalEventSource = null;
                        };
                    } catch(e){ console.error('Failed to open global SSE:', e); }
                }).catch(function(e){
                    console.debug('Global SSE debug check failed, skipping global SSE (error):', e);
                });
            }



            // Start global SSE immediately on load
            try { startGlobalEventSource(); } catch(e) {}

            // Modal duration ticker (updates the Job Details modal duration every second)
            function updateModalDuration() {
                try {
                    const id = window._currentJobId;
                    if (!id) return;
                    const startEl = document.getElementById('job-start-time');
                    const durEl = document.getElementById('job-duration');
                    if (!startEl || !durEl) return;
                    const startRaw = startEl.dataset.start || startEl.textContent || '';
                    const secs = computeDurationSecondsFromStart(startRaw);
                    if (secs !== null) {
                        durEl.textContent = formatDuration(secs);
                    }
                } catch (e) {}
            }

            function startJobModalDurationTicker() {
                if (window._jobModalDurationTicker) return;
                updateModalDuration();
                window._jobModalDurationTicker = setInterval(updateModalDuration, 1000);
            }

            function stopJobModalDurationTicker() {
                if (window._jobModalDurationTicker) { clearInterval(window._jobModalDurationTicker); window._jobModalDurationTicker = null; }
            }

            function stopJobEventSource() {
                if (window._jobEventSource) {
                    try { window._jobEventSource.close(); } catch (e) {}
                    window._jobEventSource = null;
                }
                if (window._jobSseIdleTimer) { clearTimeout(window._jobSseIdleTimer); window._jobSseIdleTimer = null; }
            }

            // Helper: deterministic HSL color for stack badges (client-side)
            function stackColor(name) {
                if (!name) return '#6c757d';
                let h = 0;
                for (let i = 0; i < name.length; i++) {
                    h = (h * 31 + name.charCodeAt(i)) % 360;
                }
                return `hsl(${h}, 65%, 45%)`;
            }

            // Insert a job row at the top of the Recent Jobs table if it doesn't exist
            function addOrInsertJobRow(job) {
                try {
                    const tbody = document.querySelector('table.table.table-hover.table-sm tbody');
                    if (!tbody) return;

                    // Remove any pending placeholder rows for the same archive_id
                    try {
                        if (job.archive_id) {
                            const pending = tbody.querySelectorAll(`tr[data-pending-archive="${job.archive_id}"]`);
                            pending.forEach(p => p.remove());
                        }
                    } catch (e) {}

                    let existing = document.getElementById(`job-row-${job.id}`);
                    if (existing) {
                        updateJobRowFromJob(job);
                        return;
                    }

                    // Build stacks badges
                    let stacksHtml = '<span class="text-muted small">N/A</span>';
                    if (job.stack_names) {
                        const parts = job.stack_names.split(',').filter(s => s && s.trim());
                        if (parts.length) {
                            stacksHtml = parts.slice(0,3).map(s => `<span class="badge" style="background-color: ${stackColor(s)}; color: white;">${s}</span>`).join('');
                            if (parts.length > 3) stacksHtml += `<span class="badge bg-secondary">+${parts.length - 3}</span>`;
                        }
                    }

                    const tr = document.createElement('tr');
                    tr.id = `job-row-${job.id}`;
                    tr.setAttribute('data-job-id', job.id);
                    tr.setAttribute('data-job-status', job.status || 'running');

                    tr.style.cursor = 'pointer';
                    // Inline safe onclick for classic behavior
                    tr.setAttribute('onclick', "(function(e){ (e||window.event||{}).stopPropagation && (e||window.event).stopPropagation(); try { if (typeof showJobDetails === 'function') showJobDetails(" + job.id + "); } catch(err){ console.error(err); } })(event)");
                    // Attach full handlers (keyboard + defensive JS handlers)
                    try { attachJobRowHandlers(tr, job.id); } catch (e) {} ;

                    tr.innerHTML = `
                        <td class="align-middle" style="white-space: nowrap;">
                            <div class="d-inline-flex align-items-center">
                                <strong class="me-2">#${job.id}</strong>

                            </div>
                        </td>
                        <td><span class="badge ${job.status === 'success' ? 'bg-success' : (job.status === 'running' ? 'bg-info' : 'bg-danger')}">${job.status}</span></td>
                        <td>${job.job_type || 'archive'}</td>
                        <td>${job.archive_name || 'N/A'}</td>
                        <td>${stacksHtml}</td>
                        <td class="d-none d-md-table-cell"><small style="white-space: nowrap;" id="row-job-start-${job.id}">${job.start_time ? formatJobTime(job.start_time) : 'N/A'}</small></td>
                        <td class="d-none d-md-table-cell"><small style="white-space: nowrap;" id="row-job-end-${job.id}">${job.end_time ? formatJobTime(job.end_time) : 'N/A'}</small></td>
                        <td><small id="row-job-duration-${job.id}">${job.duration_seconds !== null && job.duration_seconds !== undefined ? job.duration_seconds + 's' : 'N/A'}</small></td>
                        <td style="text-align: right;"><span id="row-job-size-${job.id}">${job.total_size_bytes ? `<span class="text-success">+${formatBytes(job.total_size_bytes)}</span>` : '<span class="text-muted">N/A</span>'}</span></td>
                    `;

                    // Insert at top
                    tbody.insertBefore(tr, tbody.firstChild);

                    // Attach robust click + keyboard handlers to ensure modal opens when a row is clicked
                    try {
                        attachJobRowHandlers(tr, job.id);
                    } catch (e) {
                    }

                    // Fetch full job data to populate any missing details (best-effort)
                    (async function() {
                        try {
                            const resp = await fetch(`/api/jobs/${job.id}`);
                            if (!resp.ok) return;
                            const data = await resp.json();
                            if (data && data.job) {
                                updateJobRowFromJob(data.job);
                            }
                        } catch (e) {
                        }
                    })();

                    // Temporary highlight to indicate a new job was added
                    try {
                        tr.style.backgroundColor = '#fff3cd';
                        setTimeout(() => { tr.style.transition = 'background-color 1s ease'; tr.style.backgroundColor = ''; }, 1200);
                    } catch (e) {}
                } catch (e) {
                    console.error('Failed to insert job row:', e);
                }
            }

            // Global Jobs SSE removed ‚Äî dashboard uses polling now.

            // Helper to attach click/keyboard handlers to a job row
            function attachJobRowHandlers(tr, jobId) {
                try {
                    tr.addEventListener('click', function(e) {
                        try {
                            // Ignore clicks on controls inside the row (buttons/links)
                            if (e && e.target && (e.target.closest('button') || e.target.closest('a'))) return;

                            // Prevent duplicate modal opens
                            if (window._currentJobId && String(window._currentJobId) === String(jobId)) return;
                            if (typeof showJobDetails === 'function') {
                                showJobDetails(parseInt(jobId, 10));
                            } else {
                                console.warn('showJobDetails not available when clicking job row', jobId);
                            }
                        } catch (err) {
                            console.error('Error in job row click handler', err);
                            try { alert('Error opening job details: ' + (err && err.message ? err.message : err)); } catch (e) {}
                        }
                    });

                    // Keyboard support (Enter key)
                    tr.addEventListener('keydown', function(e) {
                        try {
                            if (e && e.key === 'Enter') {
                                if (typeof showJobDetails === 'function') showJobDetails(parseInt(jobId, 10));
                            }
                        } catch (err) {
                            console.error('Error in job row keydown handler', err);
                        }
                    });

                    // Make row focusable for keyboard access
                    tr.tabIndex = 0;
                } catch (e) {
                }
            }

            // Attach handlers to any existing job rows on page (dashboard, history, etc.)
            try {
                document.querySelectorAll('tr[data-job-id]').forEach(function(tr) {
                    try {
                        const id = tr.getAttribute('data-job-id');
                        if (id) attachJobRowHandlers(tr, id);
                    } catch (e) {}
                });
            } catch (e) {}



            // Run Now behavior is handled by the surrounding <form> (no JS interception needed).

            function addPendingJobRow(archiveId, archiveName) {
                // Create a placeholder row with a negative id
                const job = {
                    id: `pending-${Date.now()}`,
                    archive_id: archiveId,
                    archive_name: archiveName,
                    job_type: 'archive',
                    status: 'starting',
                    start_time: new Date().toISOString(),
                    total_size_bytes: null,
                    stack_names: ''
                };
                try {
                    const tbody = document.querySelector('table.table.table-hover.table-sm tbody');
                    if (!tbody) return;
                    // Remove any existing pending rows for same archive
                    const old = tbody.querySelectorAll(`tr[data-pending-archive="${archiveId}"]`);
                    old.forEach(o => o.remove());

                    // Build row using the existing insertion function but mark as pending
                    const tr = document.createElement('tr');
                    tr.id = `job-row-${job.id}`;
                    tr.setAttribute('data-job-id', job.id);
                    tr.setAttribute('data-job-status', job.status || 'starting');
                    tr.setAttribute('data-pending-archive', archiveId);
                    tr.style.cursor = 'pointer';
                    tr.innerHTML = `
                        <td class="align-middle" style="white-space: nowrap;">
                            <div class="d-inline-flex align-items-center">
                                <strong class="me-2">#${job.id}</strong>

                            </div>
                        </td>
                        <td><span class="badge bg-info">starting</span></td>
                        <td>${job.job_type || 'archive'}</td>
                        <td>${job.archive_name || 'N/A'}</td>
                        <td><span class="text-muted small">N/A</span></td>
                        <td class="d-none d-md-table-cell"><small style="white-space: nowrap;">${new Date().toISOString().substring(0,16).replace('T',' ')}</small></td>
                        <td class="d-none d-md-table-cell"><small style="white-space: nowrap;">N/A</small></td>
                        <td><small>N/A</small></td>
                        <td style="text-align: right;"><span class="text-muted">N/A</span></td>
                    `;
                    attachJobRowHandlers(tr, job.id);
                    tbody.insertBefore(tr, tbody.firstChild);
                    tr.style.backgroundColor = '#fff3cd';
                    setTimeout(() => { tr.style.transition = 'background-color 1s ease'; tr.style.backgroundColor = ''; }, 1200);
                } catch (e) {
                    console.error('Failed to add pending job row:', e);
                }
            }

            function stopJobsEventSource() {
                // No-op: global Jobs SSE disabled
            }

            // Handle incoming SSE payloads for the Job Details modal
            function handleSseEvent(payload) {
                if (!payload || !payload.type) return;

                // Log lines
                if (payload.type === 'log') {
                    const data = payload.data;
                    if (Array.isArray(data)) {
                        data.forEach(l => appendLogLine(l));
                    } else if (typeof data === 'string') {
                        appendLogLine(data);
                    } else if (data && data.lines) {
                        data.lines.forEach(l => appendLogLine(l));
                    } else if (data && data.line) {
                        appendLogLine(data.line);
                    }
                    return;
                }

                // Job/status updates
                if (payload.type === 'job' || payload.type === 'status') {
                    const j = payload.data || {};
                    // Merge incoming job fields
                    try { job = Object.assign({}, job || {}, j); } catch (e) {}

                    // Update status badge
                    const statusBadge = document.getElementById('job-status-badge');
                    if (statusBadge) {
                        const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                        statusBadge.className = `badge bg-${cls}`;
                        statusBadge.textContent = job.status;
                    }

                    // Update timing & size fields (best-effort); then refresh authoritative data shortly
                    const elStart = document.getElementById('job-start-time');
                    const elEnd = document.getElementById('job-end-time');
                    const elDuration = document.getElementById('job-duration');
                    const elTotal = document.getElementById('job-total-size');
                    const elReclaimed = document.getElementById('job-reclaimed');

                    if (elStart) elStart.textContent = formatJobTime(job.start_time) || elStart.textContent || 'N/A';
                    if (elEnd) elEnd.textContent = formatJobTime(job.end_time) || elEnd.textContent || 'N/A';
                    if (elDuration) elDuration.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : elDuration.textContent || 'N/A';
                    if (elTotal) elTotal.textContent = job.total_size_bytes ? formatBytes(job.total_size_bytes) : elTotal.textContent || 'N/A';
                    if (elReclaimed) elReclaimed.textContent = job.reclaimed_bytes ? formatBytes(job.reclaimed_bytes) : elReclaimed.textContent || 'N/A';

                    // Update dashboard row if present
                    const dashboardRow = document.getElementById(`job-row-${job.id}`);
                    if (dashboardRow) {
                        dashboardRow.setAttribute('data-job-status', job.status);
                        const tableBadge = dashboardRow.querySelector('td:nth-child(2) .badge');
                        if (tableBadge) {
                            const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                            tableBadge.className = `badge bg-${cls}`;
                            tableBadge.textContent = job.status;
                        }

                        const startEl = document.getElementById(`row-job-start-${job.id}`);
                        const endEl = document.getElementById(`row-job-end-${job.id}`);
                        const durEl = document.getElementById(`row-job-duration-${job.id}`);
                        const sizeEl = document.getElementById(`row-job-size-${job.id}`);

                        if (startEl) startEl.textContent = formatJobTime(job.start_time) || startEl.textContent || 'N/A';
                        if (endEl) endEl.textContent = formatJobTime(job.end_time) || endEl.textContent || 'N/A';
                        if (durEl) durEl.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : durEl.textContent || 'N/A';
                        if (sizeEl) {
                            if (job.job_type === 'archive' && job.total_size_bytes) {
                                sizeEl.innerHTML = `<span class="text-success">+${formatBytes(job.total_size_bytes)}</span>`;
                            } else if ((job.job_type === 'retention' || job.job_type == 'cleanup') && (job.reclaimed_bytes || job.reclaimed_size_bytes)) {
                                sizeEl.innerHTML = `<span class="text-warning">-${formatBytes(job.reclaimed_size_bytes || job.reclaimed_bytes)}</span>`;
                            } else {
                                sizeEl.innerHTML = `<span class="text-muted">N/A</span>`;
                            }
                        }
                    }

                    // If job finished, stop SSE, any polling, and modal duration ticker
                    if (job.status !== 'running') {
                        stopJobEventSource();
                        try { updateSseStatus('stopped'); } catch (e) {}
                        if (window._jobLogPoller) { clearTimeout(window._jobLogPoller); window._jobLogPoller = null; }
                        try { stopJobModalDurationTicker(); } catch (e) {}
                    }

                    // Refresh authoritative job info shortly to pick up any missing fields
                    try {
                        if (window._jobRefreshTimer) clearTimeout(window._jobRefreshTimer);
                        window._jobRefreshTimer = setTimeout(refreshJobInfo, 500);
                    } catch (e) {}

                    return;
                }

                // Metrics updates
                if (payload.type === 'metrics') {
                    const tbody = document.getElementById('job-metrics-body');
                    if (tbody && Array.isArray(payload.data)) {
                        tbody.innerHTML = '';
                        payload.data.forEach(m => {
                            const hasArchive = m.archive_path && !m.archive_path.includes('_download_');
                            const row = document.createElement('tr');
                            row.innerHTML = `
                                <td>${m.stack_name}</td>
                                <td><span class="badge bg-${m.status === 'success' ? 'success' : 'danger'}">${m.status}</span></td>
                                <td>${m.was_running ? '<i class="bi bi-check-circle text-success"></i>' : '<i class="bi bi-x-circle text-muted"></i>'}</td>
                                <td>${m.duration_seconds !== null && m.duration_seconds !== undefined ? m.duration_seconds + 's' : 'N/A'}</td>
                                <td>${m.archive_size_bytes ? formatBytes(m.archive_size_bytes) : 'N/A'}</td>
                                <td><small>${m.archive_path || 'N/A'}</small></td>
                                <td class="text-nowrap">${hasArchive ? `<button class="btn btn-sm btn-outline-primary me-1" onclick="requestDownload(${job.id}, '${m.stack_name}', '${m.archive_path}')" title="Download Archive"><i class="bi bi-download"></i></button>` : ''}<button class="btn btn-sm btn-outline-secondary" onclick="downloadStackLog(${job.id}, '${m.stack_name}')" title="Download Stack Log"><i class="bi bi-file-text"></i></button></td>
                            `;
                            tbody.appendChild(row);
                        });
                    }
                }
            }

            async function refreshJobInfo() {
                try {
                    const resp = await fetch(`/api/jobs/${job.id}`);
                    if (!resp.ok) return;
                    const data = await resp.json();
                    if (!data || !data.job) return;

                    // Update local job object
                    job = data.job;

                    // Update status badge
                    const statusBadge = document.getElementById('job-status-badge');
                    if (statusBadge) {
                        const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                        statusBadge.className = `badge bg-${cls}`;
                        statusBadge.textContent = job.status;
                    }

                    // Update timing & size fields
                    const elStart = document.getElementById('job-start-time');
                    const elEnd = document.getElementById('job-end-time');
                    const elDuration = document.getElementById('job-duration');
                    const elTotal = document.getElementById('job-total-size');
                    const elReclaimed = document.getElementById('job-reclaimed');

                    if (elStart) { elStart.textContent = formatJobTime(job.start_time) || 'N/A'; elStart.dataset.start = job.start_time || ''; }
                    if (elEnd) { elEnd.textContent = formatJobTime(job.end_time) || 'N/A'; elEnd.dataset.end = job.end_time || ''; }

                    // If job is running, compute duration from start_time and start modal ticker
                    if (job.status === 'running') {
                        if (elDuration) {
                            const secs = computeDurationSecondsFromStart(job.start_time);
                            elDuration.textContent = secs !== null ? formatDuration(secs) : formatDuration(0);
                        }
                        try { startJobModalDurationTicker(); } catch (e) {}
                    } else {
                        if (elDuration) elDuration.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? formatDuration(job.duration_seconds) : 'N/A';
                        try { stopJobModalDurationTicker(); } catch (e) {}
                    }

                    if (elTotal) elTotal.textContent = job.total_size_bytes ? formatBytes(job.total_size_bytes) : 'N/A';
                    if (elReclaimed) elReclaimed.textContent = job.reclaimed_bytes ? formatBytes(job.reclaimed_bytes) : 'N/A';

                    // Update metrics table if present
                    if (Array.isArray(data.metrics)) {
                        const tbody = document.getElementById('job-metrics-body');
                        if (tbody) {
                            tbody.innerHTML = '';
                            data.metrics.forEach(m => {
                                const hasArchive = m.archive_path && !m.archive_path.includes('_download_');
                                const row = document.createElement('tr');
                                row.innerHTML = `
                                    <td>${m.stack_name}</td>
                                    <td><span class="badge bg-${m.status === 'success' ? 'success' : 'danger'}">${m.status}</span></td>
                                    <td>${m.was_running ? '<i class="bi bi-check-circle text-success"></i>' : '<i class="bi bi-x-circle text-muted"></i>'}</td>
                                    <td>${m.duration_seconds !== null && m.duration_seconds !== undefined ? m.duration_seconds + 's' : 'N/A'}</td>
                                    <td>${m.archive_size_bytes ? formatBytes(m.archive_size_bytes) : 'N/A'}</td>
                                    <td><small>${m.archive_path || 'N/A'}</small></td>
                                    <td class="text-nowrap">${hasArchive ? `<button class="btn btn-sm btn-outline-primary me-1" onclick="requestDownload(${job.id}, '${m.stack_name}', '${m.archive_path}')" title="Download Archive"><i class="bi bi-download"></i></button>` : ''}<button class="btn btn-sm btn-outline-secondary" onclick="downloadStackLog(${job.id}, '${m.stack_name}')" title="Download Stack Log"><i class="bi bi-file-text"></i></button></td>
                                `;
                                tbody.appendChild(row);
                            });
                        }
                    }

                    // Also update table row in dashboard if present
                    const dashboardRow = document.getElementById(`job-row-${job.id}`);
                    if (dashboardRow) {
                        dashboardRow.setAttribute('data-job-status', job.status);
                        const tableBadge = dashboardRow.querySelector('td:nth-child(2) .badge');
                        if (tableBadge) {
                            const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                            tableBadge.className = `badge bg-${cls}`;
                            tableBadge.textContent = job.status;
                        }

                        const startEl = document.getElementById(`row-job-start-${job.id}`);
                        const endEl = document.getElementById(`row-job-end-${job.id}`);
                        const durEl = document.getElementById(`row-job-duration-${job.id}`);
                        const sizeEl = document.getElementById(`row-job-size-${job.id}`);

                        if (startEl) startEl.textContent = formatJobTime(job.start_time) || 'N/A';
                        if (endEl) endEl.textContent = formatJobTime(job.end_time) || 'N/A';
                        if (durEl) durEl.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : 'N/A';
                        if (sizeEl) {
                            if (job.job_type === 'archive' && job.total_size_bytes) {
                                sizeEl.innerHTML = `<span class="text-success">+${formatBytes(job.total_size_bytes)}</span>`;
                            } else if ((job.job_type === 'retention' || job.job_type === 'cleanup') && (job.reclaimed_bytes || job.reclaimed_size_bytes)) {
                                sizeEl.innerHTML = `<span class="text-warning">-${formatBytes(job.reclaimed_size_bytes || job.reclaimed_bytes)}</span>`;
                            } else {
                                sizeEl.innerHTML = `<span class="text-muted">N/A</span>`;
                            }
                        }
                    }

                    // If job finished, fetch final log snapshot and stop polling
                    if (job.status !== 'running') {
                        // Get final log if available and display
                        if (job.log) {
                            clearLog();
                            (job.log || '').split('\n').forEach(l => { if (l) appendLogLine(l); });
                            // Initialize tail index so subsequent polling doesn't re-append duplicate lines
                            try { lastLine = (job.log || '').split('\n').length; } catch (e) { lastLine = 0; }
                            // Ensure scrolled to bottom
                            logPre.scrollTop = logPre.scrollHeight;
                        }

                        if (window._jobLogPoller) {
                            clearTimeout(window._jobLogPoller);
                            window._jobLogPoller = null;
                        }
                    }
                } catch (err) {
                    console.error('Failed to refresh job info:', err);
                }
            }

            async function fetchTail() {
                try {
                    const resp = await fetch(`/api/jobs/${job.id}/log/tail?last_line=${lastLine}`);
                    if (!resp.ok) {
                        // If not found or error, stop polling
                        return;
                    }
                    const data = await resp.json();
                    if (data.lines && data.lines.length) {
                        data.lines.forEach(l => {
                            appendLogLine(l);
                        });
                    }
                    lastLine = data.last_line || lastLine;

                    // Indicate we're using polling (fallback)
                    try { updateSseStatus('polling'); } catch (e) {}

                    // If API returned job metadata with the tail, update modal and dashboard immediately
                    if (data.job) {
                        job = data.job;

                        // Update status badge
                        const statusBadge = document.getElementById('job-status-badge');
                        if (statusBadge) {
                            const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                            statusBadge.className = `badge bg-${cls}`;
                            statusBadge.textContent = job.status;
                        }

                        // Update timing & size fields
                        const elStart = document.getElementById('job-start-time');
                        const elEnd = document.getElementById('job-end-time');
                        const elDuration = document.getElementById('job-duration');
                        const elTotal = document.getElementById('job-total-size');
                        const elReclaimed = document.getElementById('job-reclaimed');

                        if (elStart) elStart.textContent = formatJobTime(job.start_time) || 'N/A';
                        if (elEnd) elEnd.textContent = formatJobTime(job.end_time) || 'N/A';
                        if (elDuration) elDuration.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : 'N/A';
                        if (elTotal) elTotal.textContent = job.total_size_bytes ? formatBytes(job.total_size_bytes) : 'N/A';
                        if (elReclaimed) elReclaimed.textContent = job.reclaimed_bytes ? formatBytes(job.reclaimed_bytes) : 'N/A';

                        // Update dashboard row if present
                        const dashboardRow = document.getElementById(`job-row-${job.id}`);
                        if (dashboardRow) {
                            dashboardRow.setAttribute('data-job-status', job.status);
                            const tableBadge = dashboardRow.querySelector('td:nth-child(2) .badge');
                            if (tableBadge) {
                                const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                                tableBadge.className = `badge bg-${cls}`;
                                tableBadge.textContent = job.status;
                            }

                            const startEl = document.getElementById(`row-job-start-${job.id}`);
                            const endEl = document.getElementById(`row-job-end-${job.id}`);
                            const durEl = document.getElementById(`row-job-duration-${job.id}`);
                            const sizeEl = document.getElementById(`row-job-size-${job.id}`);

                            if (startEl) startEl.textContent = formatJobTime(job.start_time) || 'N/A';
                            if (endEl) endEl.textContent = formatJobTime(job.end_time) || 'N/A';
                            if (durEl) durEl.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : 'N/A';
                            if (sizeEl) {
                                if (job.job_type === 'archive' && job.total_size_bytes) {
                                    sizeEl.innerHTML = `<span class="text-success">+${formatBytes(job.total_size_bytes)}</span>`;
                                } else if ((job.job_type === 'retention' || job.job_type === 'cleanup') && (job.reclaimed_bytes || job.reclaimed_size_bytes)) {
                                    sizeEl.innerHTML = `<span class="text-warning">-${formatBytes(job.reclaimed_size_bytes || job.reclaimed_bytes)}</span>`;
                                } else {
                                    sizeEl.innerHTML = `<span class="text-muted">N/A</span>`;
                                }
                            }
                        }
                    }

                    // Refresh metadata every 2 poll iterations (approx every 2s)
                    refreshInterval = (refreshInterval + 1) % 2;
                    if (refreshInterval === 0) {
                        refreshJobInfo();
                    }

                    if (!data.complete) {
                        // Schedule next poll
                        window._jobLogPoller = setTimeout(fetchTail, 1000);
                    } else {
                        // Final fetch to ensure latest metadata and complete log are shown
                        await refreshJobInfo();
                    }
                } catch (err) {
                    console.error('Failed to fetch log tail:', err);
                }
            }

            // Setup controls for both running and completed jobs (attach listeners and initialize UI)
            const copyBtn = document.getElementById(`job-log-copy-${job.id}`);
            if (copyBtn) copyBtn.addEventListener('click', ()=> navigator.clipboard.writeText(Array.from(document.querySelectorAll('#job-log .text')).map(e=>e.textContent).join('\n')).catch(()=>{}));
            const downloadBtn = document.getElementById(`job-log-download-${job.id}`);
            if (downloadBtn) downloadBtn.addEventListener('click', ()=> downloadLog(job.id));
            const autoBtn = document.getElementById(`job-log-toggle-autoscroll-${job.id}`);
            if (autoBtn) autoBtn.addEventListener('click', toggleAutoScroll);
            const clearBtn = document.getElementById(`job-log-clear-${job.id}`);
            if (clearBtn) clearBtn.addEventListener('click', clearLog);
            const lineBtn = document.getElementById(`job-log-toggle-linenos-${job.id}`);
            if (lineBtn) {
                lineBtn.addEventListener('click', toggleLineNumbers);
                // Initialize label and active state
                lineBtn.textContent = window._jobLogShowLineNumbers ? 'Hide #' : 'Line #';
                lineBtn.classList.toggle('btn-success', window._jobLogShowLineNumbers);
            }


            // SSE status helper
            function updateSseStatus(state) {
                const s = document.getElementById(`job-sse-status-${job.id}`);
                if (!s) return;
                if (state === 'live') {
                    s.textContent = 'Live';
                    s.className = 'badge bg-success ms-2';
                    s.title = 'Connected via SSE (live updates)';
                } else if (state === 'stopped') {
                    s.textContent = 'Stopped';
                    s.className = 'badge bg-secondary ms-2';
                    s.title = 'Stream stopped';
                } else {
                    s.textContent = 'Polling';
                    s.className = 'badge bg-secondary ms-2';
                    s.title = 'Using polling fallback';
                }
            }



            updateSseStatus('polling');

            if (job.status === 'running') {
                // Prefer SSE for live updates if available, fallback to polling
                if (typeof(EventSource) !== 'undefined') {
                    startJobEventSource();
                } else {
                    fetchTail();
                }
            }

            if (job.log) {
                // Show final log snapshot
                clearLog();
                (job.log || '').split('\n').forEach(l => { if (l) appendLogLine(l); });
                // Initialize tail index so subsequent polling doesn't re-append duplicate lines
                try { lastLine = (job.log || '').split('\n').length; } catch (e) { lastLine = 0; }
                // Apply persisted line number visibility
                document.querySelectorAll('#job-log .ln').forEach(el => el.style.display = window._jobLogShowLineNumbers ? '' : 'none');
                // Also ensure metadata is up to date
                refreshJobInfo();
            }
            
        } catch (error) {
            content.innerHTML = `<div class="alert alert-danger">Failed to load job details: ${error.message}</div>`;
        }
    }

    async function requestDownload(jobId, stackName, archivePath) {
        try {
            const response = await fetch('/api/downloads/request', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    stack_name: stackName,
                    archive_path: archivePath
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                if (data.is_folder || data.is_preparing) {
                    // Show a modal informing the user that archive preparation has started or is in-progress
                    const modalEl = document.getElementById('downloadPrepModal');
                    const msgEl = document.getElementById('downloadPrepMessage');
                    if (msgEl) msgEl.textContent = data.message || (data.is_preparing ? 'The archive is being prepared; please try again in a few minutes.' : 'The archive is being prepared; you will receive a notification when it is ready.');
                    try { if (modalEl && typeof bootstrap !== 'undefined' && bootstrap.Modal) new bootstrap.Modal(modalEl).show(); else alert(data.message); } catch(e){ alert(data.message); }

                    // Persist token in localStorage so the modal persists across reloads and start polling
                    try {
                        if (data.token) {
                            localStorage.setItem('download_prep_token', data.token);
                            // Clear any previously-muted state for this token
                            try { sessionStorage.removeItem('download_prep_muted'); } catch(e) {}
                            startDownloadStatusPolling(data.token);
                        }
                    } catch(e) {}
                } else {
                    try { localStorage.removeItem('download_prep_token'); } catch(e) {}
                    window.open(data.download_url, '_blank');
                }
            } else {
                try { showAlert('Error: ' + (data.error || 'Unknown error'), 'danger'); } catch(e){ alert('Error: ' + (data.error || 'Unknown error')); }
            }
        } catch (error) {
            alert('Error requesting download: ' + error.message);
        }
    }

    function downloadLog(jobId) {
        window.open(`/api/jobs/${jobId}/log`, '_blank');
    }

    // Polling for a token's prepare status so the modal persists across reloads
    let _downloadStatusPollInterval = null;
    async function checkDownloadStatus(token) {
        try {
            const resp = await fetch(`/api/downloads/status?token=${encodeURIComponent(token)}`);

            // If the token was removed or expired, clear persisted state and stop polling
            if (!resp.ok) {
                if (resp.status === 404 || resp.status === 410) {
                    try { localStorage.removeItem('download_prep_token'); sessionStorage.removeItem('download_prep_muted'); } catch(e){}
                    // Hide modal if visible
                    const modalEl = document.getElementById('downloadPrepModal');
                    try { if (modalEl && typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                        const inst = bootstrap.Modal.getInstance(modalEl);
                        if (inst) inst.hide();
                    }} catch(e){}
                    try { if (typeof showAlert === 'function') showAlert('Download link expired or was removed; request a new one.', 'warning'); } catch(e){}
                    return false;
                }
                // For other non-OK responses just log and keep polling
                console.error('Download status returned non-OK status', resp.status);
                return false;
            }

            const d = await resp.json();
            if (d.ready && d.download_url) {
                // Clear persisted state and any muted flag
                try { localStorage.removeItem('download_prep_token'); sessionStorage.removeItem('download_prep_muted'); } catch(e){}
                // Hide modal if visible
                const modalEl = document.getElementById('downloadPrepModal');
                try { if (modalEl && typeof bootstrap !== 'undefined' && bootstrap.Modal) {
                    const inst = bootstrap.Modal.getInstance(modalEl);
                    if (inst) inst.hide();
                }} catch(e){}
                // Auto-open download in a new tab
                window.open(d.download_url, '_blank');
                return true;
            } else {
                // If user has muted this token (closed the modal), don't force it open again
                try {
                    const muted = sessionStorage.getItem('download_prep_muted');
                    if (muted && muted === token) {
                        return false;
                    }
                } catch (e) {}

                // Show modal status
                const modalEl = document.getElementById('downloadPrepModal');
                const msgEl = document.getElementById('downloadPrepMessage');
                if (msgEl) msgEl.textContent = 'The archive is being prepared; please try again in a few minutes.';
                try { if (modalEl && typeof bootstrap !== 'undefined' && bootstrap.Modal) new bootstrap.Modal(modalEl).show(); } catch(e){}
                return false;
            }
        } catch (e) {
            console.error('Failed to check download status', e);
            return false;
        }
    }

    function startDownloadStatusPolling(token) {
        if (_downloadStatusPollInterval) clearInterval(_downloadStatusPollInterval);
        checkDownloadStatus(token);
        _downloadStatusPollInterval = setInterval(async () => {
            const ready = await checkDownloadStatus(token);
            if (ready && _downloadStatusPollInterval) {
                clearInterval(_downloadStatusPollInterval);
                _downloadStatusPollInterval = null;
            }
        }, 10000);
    }

    // On page load, resume any persisted preparing state
    document.addEventListener('DOMContentLoaded', () => {
        try {
            const t = localStorage.getItem('download_prep_token');
            if (t) startDownloadStatusPolling(t);

            // When the user dismisses the modal manually, mute repeated popups for this token
            try {
                const modalEl = document.getElementById('downloadPrepModal');
                if (modalEl) {
                    modalEl.addEventListener('hidden.bs.modal', function () {
                        try {
                            const tok = localStorage.getItem('download_prep_token');
                            if (tok) sessionStorage.setItem('download_prep_muted', tok);
                        } catch (e) {}
                    });
                    modalEl.addEventListener('show.bs.modal', function () {
                        try { sessionStorage.removeItem('download_prep_muted'); } catch (e) {}
                    });
                }
            } catch (e) {}

            // Hook send-download modal confirm handler
            try {
                const btn = document.getElementById('sendDownloadConfirm');
                if (btn) {
                    btn.addEventListener('click', async function () {
                        const email = (document.getElementById('sendDownloadEmail').value || '').trim();
                        const token = (document.getElementById('sendDownloadToken').value || '').trim();
                        const archive = (document.getElementById('sendDownloadArchivePath').value || '').trim();
                        const stack = (document.getElementById('sendDownloadStackName').value || '').trim();

                        if (!email) {
                            const fb = document.getElementById('sendDownloadFeedback');
                            if (fb) fb.textContent = 'Please enter a recipient email';
                            return;
                        }

                        try {
                            const body = {};
                            body.email = email;
                            if (token) body.token = token;
                            else if (archive) { body.archive_path = archive; if (stack) body.stack_name = stack; }

                            const resp = await fetch('/api/downloads/send_link', {
                                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)
                            });
                            const data = await resp.json();
                            if (resp.ok) {
                                // Hide modal and clear fields
                                try { const mdl = bootstrap.Modal.getInstance(document.getElementById('sendDownloadModal')); if (mdl) mdl.hide(); } catch(e){}
                                try { if (typeof showAlert === 'function') showAlert(data.message || 'Email sent', 'success'); else alert(data.message || 'Email sent'); } catch(e){}
                                // If we are on the downloads page, reload tokens
                                try { if (document.getElementById('tokensTable')) loadTokens(); } catch(e){}
                            } else {
                                const fb = document.getElementById('sendDownloadFeedback');
                                if (fb) fb.textContent = data.error || (data.message || 'Failed to send');
                            }
                        } catch (e) {
                            const fb = document.getElementById('sendDownloadFeedback');
                            if (fb) fb.textContent = 'Request failed: ' + e.message;
                        }
                    });
                }
            } catch (e) {}
        } catch (e) {}
    });

    function showSendDownloadModal(stackName, archivePath, token) {
        try {
            const emailInput = document.getElementById('sendDownloadEmail');
            const tokenInput = document.getElementById('sendDownloadToken');
            const archiveInput = document.getElementById('sendDownloadArchivePath');
            const stackInput = document.getElementById('sendDownloadStackName');
            const feedback = document.getElementById('sendDownloadFeedback');
            if (emailInput) emailInput.value = '';
            if (tokenInput) tokenInput.value = token || '';
            if (archiveInput) archiveInput.value = archivePath || '';
            if (stackInput) stackInput.value = stackName || '';
            if (feedback) feedback.textContent = '';
            const modalEl = document.getElementById('sendDownloadModal');
            if (modalEl && typeof bootstrap !== 'undefined' && bootstrap.Modal) new bootstrap.Modal(modalEl).show();
        } catch (e) { console.error(e); }
    }

    function downloadStackLog(jobId, stackName) {
        window.open(`/api/jobs/${jobId}/log?stack=${encodeURIComponent(stackName)}`, '_blank');
    }

    function formatBytes(bytes) {
        if (!bytes) return 'N/A';
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        if (bytes === 0) return '0 B';
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
    }

    function formatDuration(seconds) {
        if (seconds === null || seconds === undefined) return 'N/A';
        seconds = Number(seconds);
        if (Number.isNaN(seconds)) return 'N/A';
        if (seconds < 60) return `${seconds}s`;
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        if (minutes < 60) return `${minutes}m ${secs}s`;
        const hours = Math.floor(minutes / 60);
        const mins = minutes % 60;
        return `${hours}h ${mins}m`;
    }

    function pad(n) { return String(n).padStart(2,'0'); }

    function formatJobTime(t) {
        // Parse any ISO-like timestamp and format in the client's local timezone as YYYY-MM-DD HH:MM
        if (!t) return 'N/A';
        try {
            const d = new Date(t);
            if (Number.isNaN(d.getTime())) return String(t).substring(0,16).replace('T',' ');
            return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
        } catch (e) { return String(t).substring(0,16).replace('T',' '); }
    }

    function computeDurationSecondsFromStart(startTime) {
        if (!startTime) return null;
        try {
            const s = new Date(startTime).getTime();
            if (Number.isNaN(s)) return null;
            const now = Date.now();
            const diff = Math.floor((now - s) / 1000);
            return diff >= 0 ? diff : 0;
        } catch (e) { return null; }
    }

    // Update duration cells for running jobs every second
    function updateRunningDurations() {
        try {
            const runningRows = document.querySelectorAll('tr[data-job-status="running"]');
            if (!runningRows || runningRows.length === 0) {
                // If we have a ticker running, stop it
                if (window._dashboardDurationTicker) { clearInterval(window._dashboardDurationTicker); window._dashboardDurationTicker = null; }
                return;
            }

            runningRows.forEach(row => {
                try {
                    const id = row.getAttribute('data-job-id');
                    if (!id) return;
                    const durEl = document.getElementById(`row-job-duration-${id}`);
                    const startEl = document.getElementById(`row-job-start-${id}`);
                    if (!durEl || !startEl) return;
                    const startRaw = startEl.dataset.start || startEl.textContent || '';
                    const secs = computeDurationSecondsFromStart(startRaw);
                    if (secs !== null) durEl.textContent = formatDuration(secs);
                } catch (e) {}
            });
        } catch (e) {}
    }

    function startDashboardDurationTicker() {
        if (window._dashboardDurationTicker) return;
        window._dashboardDurationTicker = setInterval(updateRunningDurations, 1000);
    }

    function stopDashboardDurationTicker() {
        if (window._dashboardDurationTicker) { clearInterval(window._dashboardDurationTicker); window._dashboardDurationTicker = null; }
    }

    // Edit Archive Modal - Navigate to archives page
    function editArchive(archiveId) {
        localStorage.setItem('openEditModal', archiveId);
        window.location.href = "{{ url_for('dashboard.index') }}";
    }
    </script>
    
    {% block extra_js %}{% endblock %}
</body>
</html>
