<!doctype html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="csrf-token" content="{{ csrf_token() }}">
    <title>Docker Archiver</title>
    <link rel="icon" href="{{ url_for('static', filename='icons/Icon.png') }}" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <style>
    /* Log terminal styles */
    .log {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', 'Courier New', monospace;
        font-size: 0.9rem;
        line-height: 1.4rem;
        color: #e6e6e6;
    }
    .log-line { display: flex; gap: 8px; padding: 2px 4px; }
    .log-line .ln { color: #777; width: 40px; flex: 0 0 40px; text-align: right; user-select: none; }
    .log-line .text { white-space: pre-wrap; word-break: break-word; flex: 1 1 auto; }
    .level-ERROR { color: #ff6b6b; font-weight: 700; }
    .level-WARNING { color: #ffc542; font-weight: 600; }
    .level-INFO { color: #6bc8ff; }
    .level-DEBUG { color: #9aa4b2; }
    .log-line.muted { opacity: 0.8; }
    .log-highlight { background: rgba(255,255,0,0.12); }
    .paused-indicator { display:inline-block; background:#ff6b6b; color:white; padding:2px 6px; border-radius:4px; font-weight:600; margin-left:8px; }
    </style>
</head>
<body>
    {% if session.user_id %}
    <aside class="app-sidebar" id="app-sidebar">
        <!-- Logo -->
        <div class="sidebar-header">
            <a href="{{ url_for('index') }}" class="d-flex align-items-center text-decoration-none">
                <img src="{{ url_for('static', filename='images/Logo.png') }}" alt="Docker Archiver" style="max-width: 200px; height: auto;">
            </a>
        </div>

        <!-- Navigation -->
        <ul class="nav flex-column">
            <li class="nav-item"><a class="nav-link" href="{{ url_for('index') }}"><i class="bi bi-house-door me-2"></i>Dashboard</a></li>
            <li class="nav-item"><a class="nav-link" href="{{ url_for('archives.list_archives') }}"><i class="bi bi-archive me-2"></i>Archives</a></li>
            <li class="nav-item"><a class="nav-link" href="{{ url_for('history.list_history') }}"><i class="bi bi-clock-history me-2"></i>History</a></li>
            <li class="nav-item"><a class="nav-link" href="{{ url_for('profile.manage_profile') }}"><i class="bi bi-person me-2"></i>Profile</a></li>
            <li class="nav-item"><a class="nav-link" href="{{ url_for('settings.manage_settings') }}"><i class="bi bi-gear me-2"></i>Settings</a></li>
        </ul>

        <!-- Sidebar Bottom -->
        <div class="sidebar-bottom">
            <div class="d-flex justify-content-center gap-3 mb-3">
                <a href="https://github.com/drgimpfen/Docker-Archiver/" target="_blank" rel="noopener" title="GitHub">
                    <img src="{{ url_for('static', filename='icons/github-mark-white.png') }}" alt="GitHub" class="theme-icon-dark" style="height:20px;" />
                    <img src="{{ url_for('static', filename='icons/github-mark.png') }}" alt="GitHub" class="theme-icon-light" style="height:20px;display:none;" />
                </a>
                <a href="https://discord.gg/Tq84tczrR2" target="_blank" rel="noopener" title="Discord">
                    <img src="{{ url_for('static', filename='icons/Discord-Symbol-White.png') }}" alt="Discord" class="theme-icon-dark" style="height:20px;" />
                    <img src="{{ url_for('static', filename='icons/Discord-Symbol-Black.png') }}" alt="Discord" class="theme-icon-light" style="height:20px;display:none;" />
                </a>
                <a id="theme-toggle" href="#" title="Toggle theme" style="font-size: 20px; text-decoration: none;">üåô</a>
            </div>
            <a href="{{ url_for('logout') }}" class="btn btn-outline-danger btn-sm w-100 mb-2">
                <i class="bi bi-box-arrow-right me-1"></i>Logout
            </a>
            <div class="text-center">
                <small class="text-muted">v{{ app_version }}</small>
            </div>
        </div>
    </aside>

    <!-- Mobile Toggle Button -->
    <button id="sidebar-toggle" class="btn btn-outline-secondary d-lg-none" style="position: fixed; top: 10px; left: 10px; z-index: 1040;" aria-label="Toggle menu">‚ò∞</button>
    {% endif %}

    <main class="app-main mt-4">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                {% for category, message in messages %}
                    <div class="alert alert-{{ category }} alert-dismissible fade show" role="alert">
                        {{ message }}
                        <button type="button" class="btn-close" data-bs-dismiss="alert" aria-label="Close"></button>
                    </div>
                {% endfor %}
            {% endif %}
        {% endwith %}


        {% block content %}{% endblock %}
    </main>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // CSRF Token setup for AJAX requests
        (function(){
            const csrfToken = document.querySelector('meta[name="csrf-token"]');
            if (csrfToken) {
                // Setup default headers for fetch
                const originalFetch = window.fetch;
                window.fetch = function(...args) {
                    if (args[1] && (args[1].method === 'POST' || args[1].method === 'PUT' || args[1].method === 'DELETE')) {
                        args[1].headers = args[1].headers || {};
                        args[1].headers['X-CSRFToken'] = csrfToken.content;
                    }
                    return originalFetch.apply(this, args);
                };
            }
        })();

        // LocalStorage helpers for 'follow' feature
        function getFollowedJobs() {
            try { return JSON.parse(localStorage.getItem('followedJobs') || '[]'); } catch (e) { return []; }
        }
        function setFollowedJobs(list) {
            try { localStorage.setItem('followedJobs', JSON.stringify(list)); } catch (e) {}
        }
        function isJobFollowed(jobId) {
            return getFollowedJobs().includes(String(jobId));
        }
        function setJobFollowed(jobId, value) {
            const list = getFollowedJobs().filter(x=>x);
            const s = String(jobId);
            const exists = list.includes(s);
            if (value && !exists) list.push(s);
            if (!value && exists) {
                const idx = list.indexOf(s); if (idx !== -1) list.splice(idx,1);
            }
            setFollowedJobs(list);
        }

        // Persisted Line Number setting
        function getShowLineNumbers() {
            try { return localStorage.getItem('showLineNumbers') === 'true'; } catch (e) { return false; }
        }
        function setShowLineNumbers(v) {
            try { localStorage.setItem('showLineNumbers', v ? 'true' : 'false'); } catch (e) {}
        }

        // Global follow toggle for index rows
        function toggleFollow(jobId) {
            const row = document.getElementById(`job-row-${jobId}`);
            if (!row) return;
            const current = row.getAttribute('data-follow') === 'true';
            const newVal = !current;
            row.setAttribute('data-follow', newVal.toString());
            // Persist
            setJobFollowed(jobId, newVal);
            // Update any modal or index follow buttons
            document.querySelectorAll(`#job-follow-toggle-${jobId}`).forEach(btn => btn.classList.toggle('btn-success', newVal));
            // If following and the job is running, open details
            if (newVal && row.getAttribute('data-job-status') === 'running') {
                showJobDetails(jobId);
            }
        }

        // Initialize follow state on page load
        document.addEventListener('DOMContentLoaded', ()=>{
            const followed = getFollowedJobs();
            followed.forEach(id => {
                const row = document.getElementById(`job-row-${id}`);
                if (row) row.setAttribute('data-follow','true');
                document.querySelectorAll(`#job-follow-toggle-${id}`).forEach(btn => btn.classList.add('btn-success'));
            });
        });
        
        // Bootstrap 5 native theme toggle
        (function(){
            const toggle = document.getElementById('theme-toggle');
            const htmlElement = document.documentElement;
            
            // Get stored theme or default to dark
            const storedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const currentTheme = storedTheme || (prefersDark ? 'dark' : 'light');
            
            // Set initial theme
            htmlElement.setAttribute('data-bs-theme', currentTheme);
            updateThemeIcon(currentTheme);
            
            // Toggle handler
            if (toggle) {
                toggle.addEventListener('click', function(e) {
                    e.preventDefault();
                    const theme = htmlElement.getAttribute('data-bs-theme');
                    const newTheme = theme === 'dark' ? 'light' : 'dark';
                    htmlElement.setAttribute('data-bs-theme', newTheme);
                    localStorage.setItem('theme', newTheme);
                    updateThemeIcon(newTheme);
                });
            }
            
            function updateThemeIcon(theme) {
                if (toggle) {
                    toggle.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
                    toggle.title = theme === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
                }
            }
        })();
    </script>
    <script>
        // Add class when sidebar exists so we only shift main content when sidebar is present
        (function(){
            if (document.getElementById('app-sidebar')) {
                document.body.classList.add('has-sidebar');
            }
        })();

        // Update theme icons visibility
        function updateThemeIcons() {
            const isDark = document.documentElement.getAttribute('data-bs-theme') === 'dark';
            document.querySelectorAll('.theme-icon-dark').forEach(el => el.style.display = isDark ? '' : 'none');
            document.querySelectorAll('.theme-icon-light').forEach(el => el.style.display = isDark ? 'none' : '');
        }
        updateThemeIcons();
        
        // Observe theme changes
        const observer = new MutationObserver(updateThemeIcons);
        observer.observe(document.documentElement, { attributes: true, attributeFilter: ['data-bs-theme'] });
    </script>
    <script>
        // Sidebar toggle for small screens
        (function(){
            const btn = document.getElementById('sidebar-toggle');
            const body = document.body;
            btn && btn.addEventListener('click', function(e){
                e.preventDefault();
                body.classList.toggle('sidebar-open');
            });
        })();
    </script>
    
    <!-- Job Details Modal (shared across pages) -->
    <div class="modal fade" id="jobDetailsModal" tabindex="-1">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="bi bi-info-circle"></i> Job Details
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body" id="jobDetailsContent">
                    <div class="text-center">
                        <div class="spinner-border" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
    // Safety placeholder: ensure `startJobsEventSource` exists even if rest of the script fails to execute
    if (!window.startJobsEventSource) {
        window.startJobsEventSource = function() { console.warn('startJobsEventSource placeholder called (SSE disabled)'); };
    }

    // Shared job details modal function
    async function showJobDetails(jobId) {
        try {
        } catch (e) {}
        // Track currently-open modal job id for dashboard polling
        window._currentJobId = jobId;
        const modalEl = document.getElementById('jobDetailsModal');
        if (!modalEl) {
            console.error('Job details modal element not found');
            alert('Could not open job details: modal element missing');
            return;
        }

        let modal;
        try {
            modal = new bootstrap.Modal(modalEl);
        } catch (e) {
            console.error('Bootstrap Modal constructor failed', e);
            alert('Could not open job details: modal library not available');
            return;
        }

        const content = document.getElementById('jobDetailsContent');
        try {
            modal.show();
        } catch (e) {
            console.error('Failed to show modal', e);
            alert('Could not open job details: ' + (e && e.message ? e.message : e));
            return;
        }

        // Clear current job id when modal is hidden
        modalEl.addEventListener('hide.bs.modal', () => {
            window._currentJobId = null;
            if (window._jobLogPoller) {
                clearTimeout(window._jobLogPoller);
                window._jobLogPoller = null;
            }
            // Stop any SSE connection
            if (window._jobEventSource) {
                try { window._jobEventSource.close(); } catch(e) {}
                window._jobEventSource = null;
            }
        }, { once: true });
        
        try {
            const response = await fetch(`/api/jobs/${jobId}`);
            const data = await response.json();
            
            if (data.error) {
                content.innerHTML = `<div class="alert alert-danger">${data.error}</div>`;
                return;
            }
            
            const job = data.job;
            const metrics = data.metrics;
            
            let html = `
                <div class="row mb-4">
                    <div class="col-md-6">
                        <h6>Job Information</h6>
                        <table class="table table-sm">
                            <tr><th width="150">Job ID:</th><td>#${job.id}</td></tr>
                            <tr><th>Archive:</th><td id="job-archive-name">${job.archive_name || 'N/A'}</td></tr>
                            <tr><th>Type:</th><td id="job-type">${job.job_type} ${job.is_dry_run ? '<span class="badge bg-secondary">DRY RUN</span>' : ''}</td></tr>
                            <tr><th>Status:</th><td><span id="job-status-badge" class="badge bg-${job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger')}">${job.status}</span></td></tr>
                            <tr><th>Triggered By:</th><td id="job-triggered-by">${job.triggered_by}</td></tr>
                        </table>
                    </div>
                    <div class="col-md-6">
                        <h6>Timing & Size</h6>
                        <table class="table table-sm">
                            <tr><th width="150">Start Time:</th><td id="job-start-time">${job.start_time || 'N/A'}</td></tr>
                            <tr><th>End Time:</th><td id="job-end-time">${job.end_time || 'N/A'}</td></tr>
                            <tr><th>Duration:</th><td id="job-duration">${job.duration_seconds !== null && job.duration_seconds !== undefined ? job.duration_seconds + 's' : 'N/A'}</td></tr>
                            <tr><th>Total Size:</th><td id="job-total-size">${job.total_size_bytes ? formatBytes(job.total_size_bytes) : 'N/A'}</td></tr>
                            <tr><th>Reclaimed:</th><td id="job-reclaimed">${job.reclaimed_bytes ? formatBytes(job.reclaimed_bytes) : 'N/A'}</td></tr>
                        </table>
                    </div>
                </div>
            `;
            
            if (job.error_message) {
                html += `
                    <div class="alert alert-danger">
                        <h6>Error</h6>
                        <pre>${job.error_message}</pre>
                    </div>
                `;
            }
            
            if (metrics && metrics.length > 0) {
                html += `
                    <h6 class="mt-4">Stack Metrics</h6>
                    <table class="table table-sm">
                        <thead>
                            <tr>
                                <th>Stack</th>
                                <th>Status</th>
                                <th>Was Running</th>
                                <th>Duration</th>
                                <th>Archive Size</th>
                                <th>Archive Path</th>
                                <th style="width: 80px;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="job-metrics-body">
                `;
                
                metrics.forEach(m => {
                    const hasArchive = m.archive_path && !m.archive_path.includes('_download_');
                    html += `
                        <tr>
                            <td>${m.stack_name}</td>
                            <td><span class="badge bg-${m.status === 'success' ? 'success' : 'danger'}">${m.status}</span></td>
                            <td>${m.was_running ? '<i class="bi bi-check-circle text-success"></i>' : '<i class="bi bi-x-circle text-muted"></i>'}</td>
                            <td>${m.duration_seconds !== null && m.duration_seconds !== undefined ? m.duration_seconds + 's' : 'N/A'}</td>
                            <td>${m.archive_size_bytes ? formatBytes(m.archive_size_bytes) : 'N/A'}</td>
                            <td><small>${m.archive_path || 'N/A'}</small></td>
                            <td class="text-nowrap">
                                ${hasArchive ? `<button class="btn btn-sm btn-outline-primary me-1" onclick="requestDownload(${job.id}, '${m.stack_name}', '${m.archive_path}')" title="Download Archive"><i class="bi bi-download"></i></button>` : ''}
                                <button class="btn btn-sm btn-outline-secondary" onclick="downloadStackLog(${job.id}, '${m.stack_name}')" title="Download Stack Log"><i class="bi bi-file-text"></i></button>
                            </td>
                        </tr>
                    `;
                });
                
                html += `
                        </tbody>
                    </table>
                `;
            }
            
            html += `
                <h6 class="mt-4">Log Output
                    <small class="text-muted ms-2">(terminal)</small>
                </h6>
                <div class="d-flex gap-2 align-items-center mb-2">
                    <input id="job-log-search-${job.id}" class="form-control form-control-sm" placeholder="Search log..." style="max-width: 300px;" oninput="(function(){ const v=this.value.toLowerCase(); document.querySelectorAll('#job-log .log-line').forEach(el=>el.classList.toggle('log-highlight', v && el.textContent.toLowerCase().includes(v))); }).call(this)">
                    <button id="job-log-copy-${job.id}" class="btn btn-sm btn-outline-secondary">Copy</button>
                    <button id="job-log-download-${job.id}" class="btn btn-sm btn-outline-secondary">Download</button>
                    <button id="job-log-toggle-autoscroll-${job.id}" class="btn btn-sm btn-outline-primary">Pause</button>
                    <button id="job-log-clear-${job.id}" class="btn btn-sm btn-outline-danger">Clear</button>
                    <button id="job-log-toggle-linenos-${job.id}" class="btn btn-sm btn-outline-secondary">Line #</button>
                    <button id="job-follow-toggle-${job.id}" class="btn btn-sm btn-outline-secondary"><i class="bi bi-bullseye"></i> Follow</button>
                    <span id="job-sse-status-${job.id}" class="badge bg-secondary ms-2">Polling</span>
                    <span id="job-paused-indicator-${job.id}" class="paused-indicator" style="display:none;">PAUSED</span>
                </div>
                <div id="job-log" class="bg-dark text-light p-0 mb-2 log console" style="max-height: 400px; overflow-y: auto; border-radius:6px; box-shadow: 0 6px 18px rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.04); background: linear-gradient(180deg, #0b0f12 0%, #0f1417 100%);">
                    <div class="console-header">
                        <div class="console-controls" aria-hidden="true">
                            <span class="dot dot-red"></span>
                            <span class="dot dot-yellow"></span>
                            <span class="dot dot-green"></span>
                        </div>
                        <div class="console-title">Terminal</div>
                    </div>
            `;

            content.innerHTML = html;

            // --- Live log polling & job refresh ---
            // Clear existing poller if present
            if (window._jobLogPoller) {
                clearTimeout(window._jobLogPoller);
                window._jobLogPoller = null;
            }

            const logPre = document.getElementById('job-log');
            let lastLine = 0;
            let refreshInterval = 0; // counter to reduce metadata fetch frequency

            // Auto-scroll toggle (default: on)
            window._jobLogAutoScroll = true;
            // Line numbers persisted setting
            window._jobLogShowLineNumbers = getShowLineNumbers();

            function toggleAutoScroll() {
                window._jobLogAutoScroll = !window._jobLogAutoScroll;
                const btn = document.getElementById(`job-log-toggle-autoscroll-${job.id}`);
                const badge = document.getElementById(`job-paused-indicator-${job.id}`);
                if (btn) btn.textContent = window._jobLogAutoScroll ? 'Pause' : 'Resume';
                if (badge) badge.style.display = window._jobLogAutoScroll ? 'none' : '';
            }

            function toggleLineNumbers() {
                window._jobLogShowLineNumbers = !window._jobLogShowLineNumbers;
                // Persist
                setShowLineNumbers(window._jobLogShowLineNumbers);
                // Toggle display for existing lines
                document.querySelectorAll('#job-log .ln').forEach(el => el.style.display = window._jobLogShowLineNumbers ? '' : 'none');
                // Update button UI
                const btn = document.getElementById(`job-log-toggle-linenos-${job.id}`);
                if (btn) {
                    btn.textContent = window._jobLogShowLineNumbers ? 'Hide #' : 'Line #';
                    btn.classList.toggle('btn-success', window._jobLogShowLineNumbers);
                }
            }

            function ensureConsoleHeader(container) {
                if (!container) return;
                if (!container.querySelector('.console-header')) {
                    const header = document.createElement('div');
                    header.className = 'console-header';
                    header.innerHTML = `
                        <div class="console-controls" aria-hidden="true">
                            <span class="dot dot-red"></span>
                            <span class="dot dot-yellow"></span>
                            <span class="dot dot-green"></span>
                        </div>
                        <div class="console-title">Terminal</div>
                    `;
                    container.insertBefore(header, container.firstChild);
                }
            }

            function clearLog() {
                const container = document.getElementById('job-log');
                if (container) {
                    // Remove only log-line children so header remains
                    container.querySelectorAll('.log-line').forEach(el => el.remove());
                }
                lastLine = 0;
                window._jobLogLineCount = 0;
            }

            function toggleLineNumbers() {
                window._jobLogShowLineNumbers = !window._jobLogShowLineNumbers;
                document.querySelectorAll('#job-log .ln').forEach(el => el.style.display = window._jobLogShowLineNumbers ? '' : 'none');
            }

            function appendLogLine(line) {
                // Normalize and split if the incoming line contains multiple timestamped entries
                if (!line) return;
                const tsGlobal = /\[\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\]/g;
                const matches = Array.from(line.matchAll(tsGlobal));
                if (matches.length > 1) {
                    // Split into chunks that each start with a timestamp
                    const parts = [];
                    for (let i = 0; i < matches.length; i++) {
                        const start = matches[i].index;
                        const end = (i + 1 < matches.length) ? matches[i + 1].index : line.length;
                        parts.push(line.slice(start, end).trim());
                    }
                    parts.forEach(p => appendLogLine(p));
                    return;
                }

                // Ensure container
                const container = document.getElementById('job-log');
                if (!container) return;
                // Ensure header exists (so modal opened later still shows it)
                ensureConsoleHeader(container);
                window._jobLogLineCount = (window._jobLogLineCount || 0) + 1;
                const div = document.createElement('div');
                div.className = 'log-line';
                const ln = document.createElement('div');
                ln.className = 'ln';
                ln.textContent = window._jobLogLineCount;
                ln.style.display = window._jobLogShowLineNumbers ? '' : 'none';
                const text = document.createElement('div');
                text.className = 'text';

                // Try to extract a leading timestamp
                let tsMatch = line.match(/^\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\]\s*/);
                if (!tsMatch) {
                    // If no leading timestamp, try to find one anywhere and trim preceding garbage
                    const anyTs = line.match(/\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\]/);
                    if (anyTs && anyTs.index !== undefined) {
                        line = line.slice(anyTs.index);
                        tsMatch = line.match(/^\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\]\s*/);
                    }
                }

                if (tsMatch) {
                    const ts = tsMatch[0];
                    const tsSpan = document.createElement('span');
                    tsSpan.className = 'ts me-2 text-muted';
                    tsSpan.textContent = ts;
                    text.appendChild(tsSpan);
                    line = line.slice(tsMatch[0].length);
                }

                // Parse level prefix like [ERROR], [WARNING], [INFO], [DEBUG]
                const m = line.match(/^(\[(ERROR|WARNING|INFO|DEBUG)\])\s*/);
                if (m) {
                    const lvlToken = m[1];
                    const lvl = m[2];
                    const levelSpan = document.createElement('span');
                    levelSpan.className = `level-${lvl}`;
                    levelSpan.textContent = lvlToken + ' ';
                    text.appendChild(levelSpan);
                    // Append rest
                    const rest = document.createTextNode(line.slice(m[0].length));
                    text.appendChild(rest);
                } else {
                    // No explicit level at start - append the full line
                    text.appendChild(document.createTextNode(line));
                }

                div.appendChild(ln);
                div.appendChild(text);
                container.appendChild(div);

                // Auto scroll if enabled
                if (window._jobLogAutoScroll !== false) {
                    container.scrollTop = container.scrollHeight;
                }
            }

            // SSE event source for live log + metadata (preferred over polling when supported)
            function startJobEventSource() {
                if (typeof(EventSource) === 'undefined') return;
                if (window._jobEventSource) return;
                try {
                    window._jobEventSource = new EventSource(`/api/jobs/${job.id}/events`);

                    window._jobEventSource.onopen = function() {
                        try { updateSseStatus('live'); } catch (e) {}
                    };

                    window._jobEventSource.onmessage = function(e) {
                        try {
                            const payload = JSON.parse(e.data);
                            handleSseEvent(payload);
                        } catch (err) {
                            // ignore parse errors
                        }
                    };

                    window._jobEventSource.onerror = function(err) {
                        // On error try to close and fall back to polling
                        console.error('SSE error for job', job.id, err);
                        try { window._jobEventSource.close(); } catch (e) {}
                        window._jobEventSource = null;
                        try { updateSseStatus('polling'); } catch (e) {}
                    };
                } catch (err) {
                    console.error('Failed to start SSE:', err);
                    try { updateSseStatus('polling'); } catch (e) {}
                }
            }

            function stopJobEventSource() {
                if (window._jobEventSource) {
                    try { window._jobEventSource.close(); } catch (e) {}
                    window._jobEventSource = null;
                }
            }

            // Helper: deterministic HSL color for stack badges (client-side)
            function stackColor(name) {
                if (!name) return '#6c757d';
                let h = 0;
                for (let i = 0; i < name.length; i++) {
                    h = (h * 31 + name.charCodeAt(i)) % 360;
                }
                return `hsl(${h}, 65%, 45%)`;
            }

            // Insert a job row at the top of the Recent Jobs table if it doesn't exist
            function addOrInsertJobRow(job) {
                try {
                    const tbody = document.querySelector('table.table.table-hover.table-sm tbody');
                    if (!tbody) return;

                    // Remove any pending placeholder rows for the same archive_id
                    try {
                        if (job.archive_id) {
                            const pending = tbody.querySelectorAll(`tr[data-pending-archive="${job.archive_id}"]`);
                            pending.forEach(p => p.remove());
                        }
                    } catch (e) {}

                    let existing = document.getElementById(`job-row-${job.id}`);
                    if (existing) {
                        updateJobRowFromJob(job);
                        return;
                    }

                    // Build stacks badges
                    let stacksHtml = '<span class="text-muted small">N/A</span>';
                    if (job.stack_names) {
                        const parts = job.stack_names.split(',').filter(s => s && s.trim());
                        if (parts.length) {
                            stacksHtml = parts.slice(0,3).map(s => `<span class="badge" style="background-color: ${stackColor(s)}; color: white;">${s}</span>`).join('');
                            if (parts.length > 3) stacksHtml += `<span class="badge bg-secondary">+${parts.length - 3}</span>`;
                        }
                    }

                    const tr = document.createElement('tr');
                    tr.id = `job-row-${job.id}`;
                    tr.setAttribute('data-job-id', job.id);
                    tr.setAttribute('data-job-status', job.status || 'running');
                    tr.setAttribute('data-follow', 'false');
                    tr.style.cursor = 'pointer';
                    // Inline safe onclick for classic behavior
                    tr.setAttribute('onclick', "(function(e){ (e||window.event||{}).stopPropagation && (e||window.event).stopPropagation(); try { if (typeof showJobDetails === 'function') showJobDetails(" + job.id + "); } catch(err){ console.error(err); } })(event)");
                    // Attach full handlers (keyboard + defensive JS handlers)
                    try { attachJobRowHandlers(tr, job.id); } catch (e) {} ;

                    tr.innerHTML = `
                        <td class="align-middle" style="white-space: nowrap;">
                            <div class="d-inline-flex align-items-center">
                                <strong class="me-2">#${job.id}</strong>
                                <button class="btn btn-sm btn-outline-secondary" onclick="(function(e){ e.stopPropagation(); toggleFollow(${job.id}); }).call(this)"><i class="bi bi-bullseye"></i></button>
                            </div>
                        </td>
                        <td><span class="badge ${job.status === 'success' ? 'bg-success' : (job.status === 'running' ? 'bg-info' : 'bg-danger')}">${job.status}</span></td>
                        <td>${job.job_type || 'archive'}</td>
                        <td>${job.archive_name || 'N/A'}</td>
                        <td>${stacksHtml}</td>
                        <td class="d-none d-md-table-cell"><small style="white-space: nowrap;" id="row-job-start-${job.id}">${job.start_time ? job.start_time.substring(0,16).replace('T',' ') : 'N/A'}</small></td>
                        <td class="d-none d-md-table-cell"><small style="white-space: nowrap;" id="row-job-end-${job.id}">${job.end_time ? job.end_time.substring(0,16).replace('T',' ') : 'N/A'}</small></td>
                        <td><small id="row-job-duration-${job.id}">${job.duration_seconds !== null && job.duration_seconds !== undefined ? job.duration_seconds + 's' : 'N/A'}</small></td>
                        <td style="text-align: right;"><span id="row-job-size-${job.id}">${job.total_size_bytes ? `<span class="text-success">+${formatBytes(job.total_size_bytes)}</span>` : '<span class="text-muted">N/A</span>'}</span></td>
                    `;

                    // Insert at top
                    tbody.insertBefore(tr, tbody.firstChild);

                    // Attach robust click + keyboard handlers to ensure modal opens when a row is clicked
                    try {
                        attachJobRowHandlers(tr, job.id);
                    } catch (e) {
                    }

                    // Fetch full job data to populate any missing details (best-effort)
                    (async function() {
                        try {
                            const resp = await fetch(`/api/jobs/${job.id}`);
                            if (!resp.ok) return;
                            const data = await resp.json();
                            if (data && data.job) {
                                updateJobRowFromJob(data.job);
                            }
                        } catch (e) {
                        }
                    })();

                    // Temporary highlight to indicate a new job was added
                    try {
                        tr.style.backgroundColor = '#fff3cd';
                        setTimeout(() => { tr.style.transition = 'background-color 1s ease'; tr.style.backgroundColor = ''; }, 1200);
                    } catch (e) {}
                } catch (e) {
                    console.error('Failed to insert job row:', e);
                }
            }

            // --- Global jobs EventSource (dashboard) ---
            window.startJobsEventSource = function() {
                if (typeof(EventSource) === 'undefined') return;
                if (window._jobsEventSource) return;
                try {
                    let backoff = 5000;
                    function open() {
                        try {
                            window._jobsEventSource = new EventSource('/api/jobs/events');

                            window._jobsEventSource.onopen = function() {
                                try { } catch (e) {}
                                backoff = 5000; // reset backoff on success
                            };

                            window._jobsEventSource.onmessage = function(e) {
                                try {
                                    const payload = JSON.parse(e.data);
                                    if (!payload || !payload.type) return;
                                    if (payload.type === 'job' || payload.type === 'status') {
                                        const j = payload.data || {};
                                        if (j.start_time) j.start_time = String(j.start_time);
                                        if (document.getElementById(`job-row-${j.id}`)) {
                                            updateJobRowFromJob(j);
                                        } else {
                                            addOrInsertJobRow(j);
                                        }
                                    }
                                } catch (err) {
                                    console.error('Error handling jobs SSE message', err);
                                }
                            };

                            window._jobsEventSource.onerror = function(err) {
                                console.error('Jobs SSE error', err);
                                try { window._jobsEventSource.close(); } catch (e) {}
                                window._jobsEventSource = null;
                                // attempt reconnect with backoff
                                setTimeout(() => { backoff = Math.min(backoff * 2, 60000); open(); }, backoff);
                            };
                        } catch (err) {
                            console.error('Failed to start Jobs SSE:', err);
                            setTimeout(open, backoff);
                            backoff = Math.min(backoff * 2, 60000);
                        }
                    }
                    open();
                } catch (err) {
                    console.error('Failed to initialize Jobs SSE:', err);
                }
            }

            // Helper to attach click/keyboard handlers to a job row
            function attachJobRowHandlers(tr, jobId) {
                try {
                    tr.addEventListener('click', function(e) {
                        try {
                            // Ignore clicks on controls inside the row (buttons/links)
                            if (e && e.target && (e.target.closest('button') || e.target.closest('a'))) return;

                            // Prevent duplicate modal opens
                            if (window._currentJobId && String(window._currentJobId) === String(jobId)) return;
                            if (typeof showJobDetails === 'function') {
                                showJobDetails(parseInt(jobId, 10));
                            } else {
                                console.warn('showJobDetails not available when clicking job row', jobId);
                            }
                        } catch (err) {
                            console.error('Error in job row click handler', err);
                            try { alert('Error opening job details: ' + (err && err.message ? err.message : err)); } catch (e) {}
                        }
                    });

                    // Keyboard support (Enter key)
                    tr.addEventListener('keydown', function(e) {
                        try {
                            if (e && e.key === 'Enter') {
                                if (typeof showJobDetails === 'function') showJobDetails(parseInt(jobId, 10));
                            }
                        } catch (err) {
                            console.error('Error in job row keydown handler', err);
                        }
                    });

                    // Make row focusable for keyboard access
                    tr.tabIndex = 0;
                } catch (e) {
                }
            }

            // Attach handlers to any existing job rows on page (dashboard, history, etc.)
            try {
                document.querySelectorAll('tr[data-job-id]').forEach(function(tr) {
                    try {
                        const id = tr.getAttribute('data-job-id');
                        if (id) attachJobRowHandlers(tr, id);
                    } catch (e) {}
                });
            } catch (e) {}



            // Handle Run Now buttons with optimistic UI insertion


            async function runArchiveFromButton(btn) {
                try {
                    const archiveId = btn.getAttribute('data-archive-id');
                    const archiveName = btn.getAttribute('data-archive-name') || 'Archive';

                    // Disable button briefly
                    btn.disabled = true;
                    const oldHtml = btn.innerHTML;
                    btn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Starting';
                    try {
                        const resp = await fetch(`/api/archives/${archiveId}/run`, { method: 'POST' });
                        const data = await resp.json();
                        if (data && data.success) {
                            // We rely on SSE to insert the job row when the server/worker publishes it.
                            // No UI popup to avoid accidental duplicate starts.
                        } else {
                            alert('Failed to start archive: ' + (data && data.error ? data.error : 'unknown'));
                        }
                    } catch (e) {
                        alert('Failed to start archive: ' + e);
                    } finally {
                        btn.disabled = false;
                        btn.innerHTML = oldHtml;
                    }
                } catch (e) {
                    console.error('Failed to handle Run Now click (runArchiveFromButton):', e);
                }
            }



            // Also attach direct listeners to existing buttons (covers some edge cases)
            document.querySelectorAll('.start-archive-btn').forEach(function(b) {
                b.addEventListener('click', function(ev) {
                    try {
                        ev.preventDefault();
                        ev.stopPropagation();
                        runArchiveFromButton(b);
                    } catch (e) {
                        console.error('Failed to handle Run Now click (direct):', e);
                    }
                });
            });

            function addPendingJobRow(archiveId, archiveName) {
                // Create a placeholder row with a negative id
                const job = {
                    id: `pending-${Date.now()}`,
                    archive_id: archiveId,
                    archive_name: archiveName,
                    job_type: 'archive',
                    status: 'starting',
                    start_time: new Date().toISOString(),
                    total_size_bytes: null,
                    stack_names: ''
                };
                try {
                    const tbody = document.querySelector('table.table.table-hover.table-sm tbody');
                    if (!tbody) return;
                    // Remove any existing pending rows for same archive
                    const old = tbody.querySelectorAll(`tr[data-pending-archive="${archiveId}"]`);
                    old.forEach(o => o.remove());

                    // Build row using the existing insertion function but mark as pending
                    const tr = document.createElement('tr');
                    tr.id = `job-row-${job.id}`;
                    tr.setAttribute('data-job-id', job.id);
                    tr.setAttribute('data-job-status', job.status || 'starting');
                    tr.setAttribute('data-pending-archive', archiveId);
                    tr.style.cursor = 'pointer';
                    tr.innerHTML = `
                        <td class="align-middle" style="white-space: nowrap;">
                            <div class="d-inline-flex align-items-center">
                                <strong class="me-2">#${job.id}</strong>
                                <button class="btn btn-sm btn-outline-secondary" onclick="(function(e){ (e||window.event||{}).stopPropagation && (e||window.event).stopPropagation(); toggleFollow('${job.id}'); })(event)"><i class="bi bi-bullseye"></i></button>
                            </div>
                        </td>
                        <td><span class="badge bg-info">starting</span></td>
                        <td>${job.job_type || 'archive'}</td>
                        <td>${job.archive_name || 'N/A'}</td>
                        <td><span class="text-muted small">N/A</span></td>
                        <td class="d-none d-md-table-cell"><small style="white-space: nowrap;">${new Date().toISOString().substring(0,16).replace('T',' ')}</small></td>
                        <td class="d-none d-md-table-cell"><small style="white-space: nowrap;">N/A</small></td>
                        <td><small>N/A</small></td>
                        <td style="text-align: right;"><span class="text-muted">N/A</span></td>
                    `;
                    attachJobRowHandlers(tr, job.id);
                    tbody.insertBefore(tr, tbody.firstChild);
                    tr.style.backgroundColor = '#fff3cd';
                    setTimeout(() => { tr.style.transition = 'background-color 1s ease'; tr.style.backgroundColor = ''; }, 1200);
                } catch (e) {
                    console.error('Failed to add pending job row:', e);
                }
            }

            function stopJobsEventSource() {
                if (window._jobsEventSource) {
                    try { window._jobsEventSource.close(); } catch (e) {}
                    window._jobsEventSource = null;
                }
            }

            // Handle incoming SSE payloads for the Job Details modal
            function handleSseEvent(payload) {
                if (!payload || !payload.type) return;

                // Log lines
                if (payload.type === 'log') {
                    const data = payload.data;
                    if (Array.isArray(data)) {
                        data.forEach(l => appendLogLine(l));
                    } else if (typeof data === 'string') {
                        appendLogLine(data);
                    } else if (data && data.lines) {
                        data.lines.forEach(l => appendLogLine(l));
                    }
                    return;
                }

                // Job/status updates
                if (payload.type === 'job' || payload.type === 'status') {
                    const j = payload.data || {};
                    // Merge incoming job fields
                    try { job = Object.assign({}, job || {}, j); } catch (e) {}

                    // Update status badge
                    const statusBadge = document.getElementById('job-status-badge');
                    if (statusBadge) {
                        const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                        statusBadge.className = `badge bg-${cls}`;
                        statusBadge.textContent = job.status;
                    }

                    // Update timing & size fields
                    const elStart = document.getElementById('job-start-time');
                    const elEnd = document.getElementById('job-end-time');
                    const elDuration = document.getElementById('job-duration');
                    const elTotal = document.getElementById('job-total-size');
                    const elReclaimed = document.getElementById('job-reclaimed');

                    if (elStart) elStart.textContent = job.start_time || 'N/A';
                    if (elEnd) elEnd.textContent = job.end_time || 'N/A';
                    if (elDuration) elDuration.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : 'N/A';
                    if (elTotal) elTotal.textContent = job.total_size_bytes ? formatBytes(job.total_size_bytes) : 'N/A';
                    if (elReclaimed) elReclaimed.textContent = job.reclaimed_bytes ? formatBytes(job.reclaimed_bytes) : 'N/A';

                    // Update dashboard row if present
                    const dashboardRow = document.getElementById(`job-row-${job.id}`);
                    if (dashboardRow) {
                        dashboardRow.setAttribute('data-job-status', job.status);
                        const tableBadge = dashboardRow.querySelector('td:nth-child(2) .badge');
                        if (tableBadge) {
                            const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                            tableBadge.className = `badge bg-${cls}`;
                            tableBadge.textContent = job.status;
                        }

                        const startEl = document.getElementById(`row-job-start-${job.id}`);
                        const endEl = document.getElementById(`row-job-end-${job.id}`);
                        const durEl = document.getElementById(`row-job-duration-${job.id}`);
                        const sizeEl = document.getElementById(`row-job-size-${job.id}`);

                        if (startEl) startEl.textContent = job.start_time || 'N/A';
                        if (endEl) endEl.textContent = job.end_time || 'N/A';
                        if (durEl) durEl.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : 'N/A';
                        if (sizeEl) {
                            if (job.job_type === 'archive' && job.total_size_bytes) {
                                sizeEl.innerHTML = `<span class="text-success">+${formatBytes(job.total_size_bytes)}</span>`;
                            } else if ((job.job_type === 'retention' || job.job_type === 'cleanup') && (job.reclaimed_bytes || job.reclaimed_size_bytes)) {
                                sizeEl.innerHTML = `<span class="text-warning">-${formatBytes(job.reclaimed_size_bytes || job.reclaimed_bytes)}</span>`;
                            } else {
                                sizeEl.innerHTML = `<span class="text-muted">N/A</span>`;
                            }
                        }
                    }

                    // If job finished, stop SSE and any polling
                    if (job.status !== 'running') {
                        stopJobEventSource();
                        try { updateSseStatus('stopped'); } catch (e) {}
                        if (window._jobLogPoller) { clearTimeout(window._jobLogPoller); window._jobLogPoller = null; }
                    }

                    return;
                }

                // Metrics updates
                if (payload.type === 'metrics') {
                    const tbody = document.getElementById('job-metrics-body');
                    if (tbody && Array.isArray(payload.data)) {
                        tbody.innerHTML = '';
                        payload.data.forEach(m => {
                            const hasArchive = m.archive_path && !m.archive_path.includes('_download_');
                            const row = document.createElement('tr');
                            row.innerHTML = `
                                <td>${m.stack_name}</td>
                                <td><span class="badge bg-${m.status === 'success' ? 'success' : 'danger'}">${m.status}</span></td>
                                <td>${m.was_running ? '<i class="bi bi-check-circle text-success"></i>' : '<i class="bi bi-x-circle text-muted"></i>'}</td>
                                <td>${m.duration_seconds !== null && m.duration_seconds !== undefined ? m.duration_seconds + 's' : 'N/A'}</td>
                                <td>${m.archive_size_bytes ? formatBytes(m.archive_size_bytes) : 'N/A'}</td>
                                <td><small>${m.archive_path || 'N/A'}</small></td>
                                <td class="text-nowrap">${hasArchive ? `<button class="btn btn-sm btn-outline-primary me-1" onclick="requestDownload(${job.id}, '${m.stack_name}', '${m.archive_path}')" title="Download Archive"><i class="bi bi-download"></i></button>` : ''}<button class="btn btn-sm btn-outline-secondary" onclick="downloadStackLog(${job.id}, '${m.stack_name}')" title="Download Stack Log"><i class="bi bi-file-text"></i></button></td>
                            `;
                            tbody.appendChild(row);
                        });
                    }
                }
            }

            async function refreshJobInfo() {
                try {
                    const resp = await fetch(`/api/jobs/${job.id}`);
                    if (!resp.ok) return;
                    const data = await resp.json();
                    if (!data || !data.job) return;

                    // Update local job object
                    job = data.job;

                    // Update status badge
                    const statusBadge = document.getElementById('job-status-badge');
                    if (statusBadge) {
                        const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                        statusBadge.className = `badge bg-${cls}`;
                        statusBadge.textContent = job.status;
                    }

                    // Update timing & size fields
                    const elStart = document.getElementById('job-start-time');
                    const elEnd = document.getElementById('job-end-time');
                    const elDuration = document.getElementById('job-duration');
                    const elTotal = document.getElementById('job-total-size');
                    const elReclaimed = document.getElementById('job-reclaimed');

                    if (elStart) elStart.textContent = job.start_time || 'N/A';
                    if (elEnd) elEnd.textContent = job.end_time || 'N/A';
                    if (elDuration) elDuration.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : 'N/A';
                    if (elTotal) elTotal.textContent = job.total_size_bytes ? formatBytes(job.total_size_bytes) : 'N/A';
                    if (elReclaimed) elReclaimed.textContent = job.reclaimed_bytes ? formatBytes(job.reclaimed_bytes) : 'N/A';

                    // Update metrics table if present
                    if (Array.isArray(data.metrics)) {
                        const tbody = document.getElementById('job-metrics-body');
                        if (tbody) {
                            tbody.innerHTML = '';
                            data.metrics.forEach(m => {
                                const hasArchive = m.archive_path && !m.archive_path.includes('_download_');
                                const row = document.createElement('tr');
                                row.innerHTML = `
                                    <td>${m.stack_name}</td>
                                    <td><span class="badge bg-${m.status === 'success' ? 'success' : 'danger'}">${m.status}</span></td>
                                    <td>${m.was_running ? '<i class="bi bi-check-circle text-success"></i>' : '<i class="bi bi-x-circle text-muted"></i>'}</td>
                                    <td>${m.duration_seconds !== null && m.duration_seconds !== undefined ? m.duration_seconds + 's' : 'N/A'}</td>
                                    <td>${m.archive_size_bytes ? formatBytes(m.archive_size_bytes) : 'N/A'}</td>
                                    <td><small>${m.archive_path || 'N/A'}</small></td>
                                    <td class="text-nowrap">${hasArchive ? `<button class="btn btn-sm btn-outline-primary me-1" onclick="requestDownload(${job.id}, '${m.stack_name}', '${m.archive_path}')" title="Download Archive"><i class="bi bi-download"></i></button>` : ''}<button class="btn btn-sm btn-outline-secondary" onclick="downloadStackLog(${job.id}, '${m.stack_name}')" title="Download Stack Log"><i class="bi bi-file-text"></i></button></td>
                                `;
                                tbody.appendChild(row);
                            });
                        }
                    }

                    // Also update table row in dashboard if present
                    const dashboardRow = document.getElementById(`job-row-${job.id}`);
                    if (dashboardRow) {
                        dashboardRow.setAttribute('data-job-status', job.status);
                        const tableBadge = dashboardRow.querySelector('td:nth-child(2) .badge');
                        if (tableBadge) {
                            const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                            tableBadge.className = `badge bg-${cls}`;
                            tableBadge.textContent = job.status;
                        }

                        const startEl = document.getElementById(`row-job-start-${job.id}`);
                        const endEl = document.getElementById(`row-job-end-${job.id}`);
                        const durEl = document.getElementById(`row-job-duration-${job.id}`);
                        const sizeEl = document.getElementById(`row-job-size-${job.id}`);

                        if (startEl) startEl.textContent = job.start_time || 'N/A';
                        if (endEl) endEl.textContent = job.end_time || 'N/A';
                        if (durEl) durEl.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : 'N/A';
                        if (sizeEl) {
                            if (job.job_type === 'archive' && job.total_size_bytes) {
                                sizeEl.innerHTML = `<span class="text-success">+${formatBytes(job.total_size_bytes)}</span>`;
                            } else if ((job.job_type === 'retention' || job.job_type === 'cleanup') && (job.reclaimed_bytes || job.reclaimed_size_bytes)) {
                                sizeEl.innerHTML = `<span class="text-warning">-${formatBytes(job.reclaimed_size_bytes || job.reclaimed_bytes)}</span>`;
                            } else {
                                sizeEl.innerHTML = `<span class="text-muted">N/A</span>`;
                            }
                        }
                    }

                    // If job finished, fetch final log snapshot and stop polling
                    if (job.status !== 'running') {
                        // Get final log if available and display
                        if (job.log) {
                            logPre.textContent = job.log;
                            logPre.scrollTop = logPre.scrollHeight;
                        }

                        if (window._jobLogPoller) {
                            clearTimeout(window._jobLogPoller);
                            window._jobLogPoller = null;
                        }
                    }
                } catch (err) {
                    console.error('Failed to refresh job info:', err);
                }
            }

            async function fetchTail() {
                try {
                    const resp = await fetch(`/api/jobs/${job.id}/log/tail?last_line=${lastLine}`);
                    if (!resp.ok) {
                        // If not found or error, stop polling
                        return;
                    }
                    const data = await resp.json();
                    if (data.lines && data.lines.length) {
                        data.lines.forEach(l => {
                            appendLogLine(l);
                        });
                    }
                    lastLine = data.last_line || lastLine;

                    // Indicate we're using polling (fallback)
                    try { updateSseStatus('polling'); } catch (e) {}

                    // If API returned job metadata with the tail, update modal and dashboard immediately
                    if (data.job) {
                        job = data.job;

                        // Update status badge
                        const statusBadge = document.getElementById('job-status-badge');
                        if (statusBadge) {
                            const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                            statusBadge.className = `badge bg-${cls}`;
                            statusBadge.textContent = job.status;
                        }

                        // Update timing & size fields
                        const elStart = document.getElementById('job-start-time');
                        const elEnd = document.getElementById('job-end-time');
                        const elDuration = document.getElementById('job-duration');
                        const elTotal = document.getElementById('job-total-size');
                        const elReclaimed = document.getElementById('job-reclaimed');

                        if (elStart) elStart.textContent = job.start_time || 'N/A';
                        if (elEnd) elEnd.textContent = job.end_time || 'N/A';
                        if (elDuration) elDuration.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : 'N/A';
                        if (elTotal) elTotal.textContent = job.total_size_bytes ? formatBytes(job.total_size_bytes) : 'N/A';
                        if (elReclaimed) elReclaimed.textContent = job.reclaimed_bytes ? formatBytes(job.reclaimed_bytes) : 'N/A';

                        // Update dashboard row if present
                        const dashboardRow = document.getElementById(`job-row-${job.id}`);
                        if (dashboardRow) {
                            dashboardRow.setAttribute('data-job-status', job.status);
                            const tableBadge = dashboardRow.querySelector('td:nth-child(2) .badge');
                            if (tableBadge) {
                                const cls = job.status === 'success' ? 'success' : (job.status === 'running' ? 'info' : 'danger');
                                tableBadge.className = `badge bg-${cls}`;
                                tableBadge.textContent = job.status;
                            }

                            const startEl = document.getElementById(`row-job-start-${job.id}`);
                            const endEl = document.getElementById(`row-job-end-${job.id}`);
                            const durEl = document.getElementById(`row-job-duration-${job.id}`);
                            const sizeEl = document.getElementById(`row-job-size-${job.id}`);

                            if (startEl) startEl.textContent = job.start_time || 'N/A';
                            if (endEl) endEl.textContent = job.end_time || 'N/A';
                            if (durEl) durEl.textContent = (job.duration_seconds !== null && job.duration_seconds !== undefined) ? job.duration_seconds + 's' : 'N/A';
                            if (sizeEl) {
                                if (job.job_type === 'archive' && job.total_size_bytes) {
                                    sizeEl.innerHTML = `<span class="text-success">+${formatBytes(job.total_size_bytes)}</span>`;
                                } else if ((job.job_type === 'retention' || job.job_type === 'cleanup') && (job.reclaimed_bytes || job.reclaimed_size_bytes)) {
                                    sizeEl.innerHTML = `<span class="text-warning">-${formatBytes(job.reclaimed_size_bytes || job.reclaimed_bytes)}</span>`;
                                } else {
                                    sizeEl.innerHTML = `<span class="text-muted">N/A</span>`;
                                }
                            }
                        }
                    }

                    // Refresh metadata every 2 poll iterations (approx every 2s)
                    refreshInterval = (refreshInterval + 1) % 2;
                    if (refreshInterval === 0) {
                        refreshJobInfo();
                    }

                    if (!data.complete) {
                        // Schedule next poll
                        window._jobLogPoller = setTimeout(fetchTail, 1000);
                    } else {
                        // Final fetch to ensure latest metadata and complete log are shown
                        await refreshJobInfo();
                    }
                } catch (err) {
                    console.error('Failed to fetch log tail:', err);
                }
            }

            // Setup controls for both running and completed jobs (attach listeners and initialize UI)
            const copyBtn = document.getElementById(`job-log-copy-${job.id}`);
            if (copyBtn) copyBtn.addEventListener('click', ()=> navigator.clipboard.writeText(Array.from(document.querySelectorAll('#job-log .text')).map(e=>e.textContent).join('\n')).catch(()=>{}));
            const downloadBtn = document.getElementById(`job-log-download-${job.id}`);
            if (downloadBtn) downloadBtn.addEventListener('click', ()=> downloadLog(job.id));
            const autoBtn = document.getElementById(`job-log-toggle-autoscroll-${job.id}`);
            if (autoBtn) autoBtn.addEventListener('click', toggleAutoScroll);
            const clearBtn = document.getElementById(`job-log-clear-${job.id}`);
            if (clearBtn) clearBtn.addEventListener('click', clearLog);
            const lineBtn = document.getElementById(`job-log-toggle-linenos-${job.id}`);
            if (lineBtn) {
                lineBtn.addEventListener('click', toggleLineNumbers);
                // Initialize label and active state
                lineBtn.textContent = window._jobLogShowLineNumbers ? 'Hide #' : 'Line #';
                lineBtn.classList.toggle('btn-success', window._jobLogShowLineNumbers);
            }
            const followBtn = document.getElementById(`job-follow-toggle-${job.id}`);
            if (followBtn) {
                // Reflect persisted follow state
                try { followBtn.classList.toggle('btn-success', isJobFollowed(job.id)); } catch (e) {}
                followBtn.addEventListener('click', ()=> toggleFollow(job.id));
            }

            // SSE status helper
            function updateSseStatus(state) {
                const s = document.getElementById(`job-sse-status-${job.id}`);
                if (!s) return;
                if (state === 'live') {
                    s.textContent = 'Live';
                    s.className = 'badge bg-success ms-2';
                    s.title = 'Connected via SSE (live updates)';
                } else if (state === 'stopped') {
                    s.textContent = 'Stopped';
                    s.className = 'badge bg-secondary ms-2';
                    s.title = 'Stream stopped';
                } else {
                    s.textContent = 'Polling';
                    s.className = 'badge bg-secondary ms-2';
                    s.title = 'Using polling fallback';
                }
            }

            updateSseStatus('polling');

            if (job.status === 'running') {
                // Prefer SSE for live updates if available, fallback to polling
                if (typeof(EventSource) !== 'undefined') {
                    startJobEventSource();
                } else {
                    fetchTail();
                }
            }

            if (job.log) {
                // Show final log snapshot
                clearLog();
                (job.log || '').split('\n').forEach(l => { if (l) appendLogLine(l); });
                // Apply persisted line number visibility
                document.querySelectorAll('#job-log .ln').forEach(el => el.style.display = window._jobLogShowLineNumbers ? '' : 'none');
                // Also ensure metadata is up to date
                refreshJobInfo();
            }
            
        } catch (error) {
            content.innerHTML = `<div class="alert alert-danger">Failed to load job details: ${error.message}</div>`;
        }
    }

    async function requestDownload(jobId, stackName, archivePath) {
        try {
            const response = await fetch(`/api/jobs/${jobId}/download`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    stack_name: stackName,
                    archive_path: archivePath
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                if (data.is_folder) {
                    alert(data.message);
                } else {
                    window.open(data.download_url, '_blank');
                }
            } else {
                alert('Error: ' + (data.error || 'Unknown error'));
            }
        } catch (error) {
            alert('Error requesting download: ' + error.message);
        }
    }

    function downloadLog(jobId) {
        window.open(`/api/jobs/${jobId}/log`, '_blank');
    }

    function downloadStackLog(jobId, stackName) {
        window.open(`/api/jobs/${jobId}/log?stack=${encodeURIComponent(stackName)}`, '_blank');
    }

    function formatBytes(bytes) {
        if (!bytes) return 'N/A';
        const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
        if (bytes === 0) return '0 B';
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];
    }
    
    // Edit Archive Modal - Navigate to archives page
    function editArchive(archiveId) {
        localStorage.setItem('openEditModal', archiveId);
        window.location.href = '/archives';
    }
    </script>
    
    {% block extra_js %}{% endblock %}
</body>
</html>
